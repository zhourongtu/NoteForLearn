参考资料：

《代码大全》

--- 
# 第一部分、打好基础
## 第1章、欢迎进入软件构件的世界
**核心目标**
- 理解`构建`是什么？
  - [构建的基本含义是什么](###构建的基本含义)
  - [**所有软件工程中的活动** 与 **构建活动** 之间的关系](###构建活动与软件开发过程中的活动的关系)
  - [构建活动中的具体任务有哪些？](###构建活动的具体任务)
- 掌握构建具有哪些特点？
  - [构建的特点](###构建活动的特点)
- 为什么要在软件开发过程中特别强调构建？
  - [为什么构建非常重要？](###为什么构建活动非常重要？)
- 总结（分布在各个链接的开头，参考了《代码大全》最后的总结，跟几次读文章最后的结果一致）
  > 最后，你对“如何进行构建”的理解程度，决定了你这名程序员的优秀程度————这就是本书其余部分的主题了。

### 构建的基本含义
- 基本含义：建设的过程。
- 通常使用的含义：建设的过程中`动手的那一部分`。

### 构建活动与软件开发过程中的活动的关系
> 构建的主要活动包括：详细设计、编码与调试、集成、开发者测试（developing testing）（包括单元测试和集成测试）
- 软件开发过程中的活动， 构建的主要内容（⭐表示）
  - 定义问题
  - 需求分析
  - 规划构建
  - 软件架构、高层设计
  - 详细设计 ⭐
  - 编码和调试 ⭐⭐⭐⭐⭐
  - 单元测试 ⭐
  - 集成测试 ⭐
  - 集成
  - 系统测试
  - 保障维护

### 构建活动的具体任务
- **确认基础工作、设计如何测试、设计、编写、测试、评审、润饰、集成、优化**。
  - 确认构建活动的基础工作已经完成，可以进行构建活动。
  - 确定如何测试构建的代码。
  - 设计如何编写类、子程序
  - 创建并命名变量和具名常量
  - 选择控制结构（control structure），组织语句块
  - 对代码进行单元测试、集成测试，排除其中的错误
  - 评审
  - 润饰代码，进行代码的格式化与注释
  - 将单独开发的多个软件集为一体。
  - 调整代码（tuning code），令他更快，更节省资源。

### 构建活动的特点
> 构建通常被称作“编码”和“编程”
- 编码、编程
  - 编码的意味：把已经存在的设计机械化地翻译成计算机语言。
- 构建并不都是机械化的，它需要`可观的创造力和判断力`。

### 为什么构建活动非常重要？
> 1.软件构件是软件开发的核心活动；构件活动是每个项目中唯一必不可少的工作。  
> 2.构建活动的质量对软件的质量有着实质性的影响。
- 构建活动是软件开发的主要组成部分（数据支撑 30% ~ 80%）
- 构建活动是软件开发的核心活动（前：需求分析、架构设计。后：测试）
- 对主要部分进行优化，提高效率。
- 构建活动的产物————源代码，是对软件的唯一精确描述。（最新）
- 构建活动是唯一确保会被完成的工作。（其他都是影响） ⭐⭐⭐⭐⭐
- 构建活动对软件的质量有着实质性的影响。⭐⭐⭐⭐

## 第2章、用隐喻来更充分地理解软件开发
**核心目标**
- 隐喻
  - [隐喻和使用隐喻](###隐喻和使用隐喻)
  - [掌握隐喻的优点和缺点以及特点](###隐喻的优点与缺点以及特点)
    > 有些隐喻比其他一些隐喻更加贴切。
  - [用什么样的心态看待隐喻](###用什么样的心态看待隐喻)
- [常见的软件隐喻](###常见的软件隐喻)
  > 建议先看常见的软件隐喻，然后再看软件隐喻
- [软件隐喻](###隐喻与软件隐喻)
  - > 使用和算法对比的方式更好地理解软件隐喻。  
  - > 隐喻在软件开发领域与其他熟悉的活动联系在一起，能帮助更好的理解软件开发的过程。  
  - > 软件的构建与房屋的建设告诉我们，准备是必要的，而大项目与小项目之间也是有差异的。
- [使用隐喻的思想](###使用隐喻的思想)
  - > 每位程序员都有许多工具，但并不存在任何一个能够适用于所有工作的工具，因地制宜的选择正确的工具是能有效编程的程序员的关键。
  - > 不同的隐喻之间并不排斥，应当使用对你最有益处的某种隐喻组合。

### 隐喻和使用隐喻
- 隐喻是一系列比喻，或者模型，用于类比你所希望理解的事物。
- 建模是使用隐喻的一种方式，通过把一些不太理解的东西和一些较为理解的、且十分类似的东西作比较，这样一来可以对不太理解的东西产生更深刻的理解。
- 模型的最大功力在于生动性，能够把握整个概念，隐隐约约暗示各种属性、关系，以及一系列需要补充查证的部分。

### 隐喻的优点与缺点以及`特点`
- [优点](###隐喻和使用隐喻)
- 缺点
  - 隐喻的概念被过度引申时，模型可能将人引入歧途。
- 特点
  - 使用不同的隐喻可以解释不同的问题，可以对问题有着不同的理解。
  - 隐喻并没有错误与正确之分，只有不是很贴切的隐喻和更贴切的隐喻。
    > 科学发展的历史并不是一系列从“错误”的隐喻到“正确”的隐喻的转变，而是一系列从“不太合适”的隐喻到“更好”的隐喻的转变，也是从`不是很贴切的隐喻`到`更贴切的隐喻`的转变，还是从在`一个方面暗示人们`到在`另一个方面暗示人们`的转变。
  - 类比参考：[科学方法的收集数据、提出假说、验证假说的循环](../../通用知识/3.科学方法.md)

### 用什么样的心态看待隐喻
- [心态](###隐喻的优点与缺点以及特点)：查看隐喻的特点的第二段。

### 隐喻与软件隐喻
- [隐喻参考](###隐喻和使用隐喻)
- 软件隐喻与算法对比来了解软件隐喻
  - 算法是一套定义明确的指令，使你能完成某个特定的任务。
    - 算法是可预测的、确定性的、不易变化的
    - 交叉参考：[算法基本定义](../../计算机基础知识相关/算法/1_2_算法入门.md#算法的基本定义)
  - 启发式方法（试探法）是帮助寻求答案的技术。
- 编程最大的挑战：将问题概念化。
  - 编程中的很多问题都是概念性的错误，每一个问题的概念都是独特的，找到一套能够解决所有问题的指导原则是困难的。所以，能一般性的知道大致如何解决问题，至少也和知道如何解决特定问题一样有价值了。
- 使用软件隐喻
  - 使用软件隐喻，应该通过它来提高你对编程问题和编程过程的洞察力；用它来帮助你思考编程过程中的活动，想象出更好的做事情的方法。
  - 你不可能看到一行代码说它违反了本章所描述的某个隐喻。但随着时间的流逝，人们会发现，相对于不善运用隐喻的人来说，那些使用隐喻来照亮自己软件开发过程的人，他们对于编程的理解会更好，并且能够更快地写出更好的代码。

### 常见的软件隐喻
- 写作
  - 特点：不需要正规地做计划，写出来就是了。注重`原创性`。
  - 软件开发的特点：`重用性`
- 耕作、培植系统
  - 特点：增量
    > 开始贴近软件开发的特点了，即增量。
  - 缺点：耕作的管理对象是土地，而不是果子，不够贴切。
- 系统生长（牡蛎养殖）：
  - 特点：`增量的(incremental)`、迭代的(iterative)、自适应的(adaptive)、演进的(evolutionary)。
    > 更加贴切了
  - 软件开发的类比：骨架、替换，依次增加。
- 建筑，软件`建造`
  - 特点
    - 1.建造推倒重来的成本高。
    - 2.适当的多层次的规划对建造建筑物和构建软件都有好处。
    - 3.现成的工具。
    - 4.特别的定制。
    - 5.获益于精心计划。
  - 交叉参考：[软件开发的流程参考](###构建活动与软件开发过程中的活动的关系)
  - 交叉参考：[构建活动的具体任务参考](###构建活动的具体任务)
    - 建筑什么样的房子————问题定义
    - 探讨建筑的总体设计————软件架构
    - 画出详细的蓝图（有一个承包人）————详细设计
    - 准备好建造地点，打好地基，搭建房屋框架，砌好墙壁，盖房顶，通水、电、煤...——————构建过程
    - 美化房屋————优化（评审、润饰、调整）、集成、保障维护
  - 其他
    - 工具
      - 软件的组件、预先制作好的家电、墙砖...
    - 定制化
      - 软件的定制化组件、定制化的家具
    - 精心计划
      - 房屋获益于此
      - 软件开发也获益于此（不同的软件开发方法）
    - 留有余地
      - 建筑留有余地
      - 软件留有余地。
  - 一些建筑领域的软件术语延申
    - 软件架构（建筑学，architecture）、支撑性代码（脚手架，scaffolding）、构建（建设，construction）、基础类（foundation classes）、以及分离代码（tearing code apart）
- 应用软件技术，智慧工具箱。
  - 把所有的技术、方法留在脑海里，在合适的时候拿来使用。

### 使用隐喻的思想
- 交叉参考：[常见的软件隐喻](###常见的软件隐喻)
- 组合思想：多个隐喻可以互相组合，达到更好的效果。

## 第3章、三思而后行：前期准备
- 1.了解前期准备的重要性
  - 使用高质量的实践方法是那些能够创造高质量软件的程序员的共性

## 4.关键的“构建”决策

## 1-4章总结


---

# 第二部分、创建高质量的代码
## 第5章、软件构件中的设计

## 第6章、可以工作的类
[ADT与类概念参考](../../计算机基础知识相关/概念知识/基础概念辨析.md#adt%E4%B8%8E%E7%B1%BB)
- 1.认识ADT与类，以下阐述ADT相关知识点
  - 好处
    - 隐藏实现细节
    - 改动不影响整个程序
    - 让接口提供更多信息
    - 容易提高程序性能
    - 让程序的正确性显而易见
    - 让程序更具自我说明性
    - 无需在程序内到处传递数据
    - 可以像在现实世界中那样操作实体，而不用在底层实现上操作它
  - 例子：字体定义
  - 指导建议
    - 把常见的数据类型创建为ADT并使用这些ADT
    - 把像文件这样的常用对象当成ADT
    - 简单的事务也可以当作ADT
    - 不要让ADT依赖于存储介质
  - 在非面向对象环境中使用ADT处理多份数据实例的三个方式
    - 使用ADT服务子程序明确指定实例（如fontId）
    - 明确地向ADT服务子程序提供所要用到的数据。
    - 使用隐含实例。
      - 比如：设计一个新的服务子程序，通过它让某个特定的字体实例成为当前实例。
      > 不推荐，系统范围内对状态的依赖，意味着需要用到字体操作时，所有代码需要跟踪当前的字体实例。
- 2.创建高质量的类
  > 第一步，也是最重要的一步，创建一个好的接口。  
  - 创建良好的接口
    - 隐含两个概念
      - 1.创建一个`可以通过接口来展现的合理的抽象`。
      - 2.并 确保`细节`被`隐藏`在抽象的背后。
    > 类的接口为实现细节提供了一种抽象，`这种抽象应该具有一致性`  (推导结论，由表现推导)。  
    > 表现为：能够提供一组明显相关的子程序。
    - 例子
      - 一个良好的抽象：雇员，一组获得雇员信息的方法。
      - 一个不良的抽象：程序，提供了各种各样的功能。
    - 指导意见
      - 类的接口应该展现一致的抽象层次
        - 一个类中 雇员抽象 + 列表抽象的例子
      - **一定要理解类所实现的抽象是什么**
        - 电子表格（150个子程序）、栅格控件（15个）
        - 使用包裹类（wrap class）隐藏“把电子表格控件用作栅格控件”这一事实。
      - 提供成对的服务
      - 把不相关的信息转移到其他类中
      - 尽可能让接口可编程，而不是表达语义（**这部分内容作为接口，放在基础概念辨析中**）
      - 谨防在修改时破坏接口的抽象
      - 不要添加与接口抽象不一致的公共成员
      - 同时考虑抽象性和内聚性（两个概念非常紧密）
        - 一个呈现出良好的抽象的类接口通常有很高的内聚性。
        - 而具有很高的内聚性的类往往也会成为很好的抽象（尽管这种关系不如前者那么强）。
     > 关注类的接口所表现出来的抽象，比关注类的内聚性更有助于深入地理解类的设计。如果觉得某个类的内聚性非常弱，也不知道怎么改，可以问问自己这个类是否表现出一致的抽象。
  - 良好的封装  
    > 封装和抽象的概念辨析，参考基础概念辨析.md。
    - 尽可能地限制类和成员的可访问性
      - 考虑`“采用哪种方式能最好地保护接口抽象的完整性”`。
    - 不要公开暴露成员数据
    - 避免把私用的实现细节放入类的接口中
      - 做到真正的封装后，程序员们应该看不到任何实现细节。（无论是字面上还是寓意上）
      - C++却从语言结构上要求程序员在类的接口中透露实现细节（在类的头文件可以看到private的变量，这鼓励程序员查阅实现细节）
      - Effective C++ 建议把类的接口和类的实现隔离开，并在类的声明中包含一个指针，让该指针指向类的实现，但不能包含其他任何细节。
    - 不要对使用者做出任何假设——除非接口有明确说明（参考接口的可编程部分、语义部分概念辨析）
    - 避免使用友元类(friend class)——破坏封装。
      - 正确的方式，如State模式中使用友元类有助于管理复杂度。
    - 不因为一个子程序里仅使用公用子程序，就把它归入公开接口。
    - 让阅读代码比编写代码更方便。
    - 要格外警惕从语义上破坏封装性。
      - 语法：设为private
      - 语义：某个函数被另外一个函数隐含调用。
    - 留意过于紧密的耦合关系
- 3.有关设计和实现的问题
  > 主要讨论 包含、继承、成员函数 和 数据成员 、类之间的耦合性、构造函数、值对象、引用对象。
  - 包含关系(has-a)
    - 使用包含实现has-a关系
    - 万不得已情况下使用private继承
      - 原因：让外层的包含类能够访问被包含类的protected成员函数与数据成员。
      - 其实也可以用其他方式解决。
    - 警惕7个以上的成员函数。（复杂考虑7-2，简单考虑7+2）
  - 继承关系（is-a）
    - public继承实现is-a关系
    - 要么使用继承并进行详细说明，否则不使用。
    - 遵循里氏替换原则（面向对象基本原则）
    - 确保继承只需要继承的那一部分。
  - 成员函数与数据成员
  - 构造函数
    - 如果可能，应该在所有的构造函数中初始化所有的数据成员。
      > 《重构》11.7，移除设值函数————清晰的表达对象不可变的意图。
    - 用私有构造函数来强制实现单件属性(single property)
    - 优先使用深层拷贝，除非论证可行，才使用浅层拷贝。
- 4.认识创建类的原因

## 第7章、高质量的子程序


## 第8章、防御式编程
防御式编程的主要思想：子程序应该不因传入的数据错误而被破坏，哪怕式由其他子程序产生的错误数据。
> 核心想法：承认程序都会有问题，都需要被修改，聪明的程序员应该根据这一点编写程序。  

> 如何面对严酷的非法数据的世界、在遇到“绝对不会发生”的事件以及其他程序员犯下的错误时，保护好你自己。  

> 应该自始自终考虑各种各样的错误处理机制，不应该由语言限制了自己。

**8.1 保护程序免遭非法输入数据破坏**
三种方法：
- 检查所有来源于外部的数据的值
- 检查子程序的所有输入参数的值
- 决定如何处理错误的输入数据
**8.2 断言**
1. 断言是用来做什么的？
   - 程序运行自检的代码
   - 断言是一种假定
2. 断言在什么时候使用？
   - 用错误处理代码来处理预期会发生的情况，用断言来处理绝不应该发生的状况
   - 执行的代码不要和断言一起使用（容易被排除在外，不编译）
3. 断言和错误处理技术是否可以同时使用？可以。
**8.3 错误处理技术**
**8.4 异常**
**8.5 隔离程序**
**8.6 辅助调试的代码**
**8.7 确定产品中保留多少防御式代码**
**8.8 对防御式编程采取防御的姿态**


---
## 第18章、表驱动法（Table-Driven Method）
**表驱动法的基本认知**：它是一种编程模式（schema），通过从表中查询数据，而不使用逻辑语句。
> 理论上所有能够使用逻辑语句来选择的事务，都可以通过查表来选择。


---
## 第23章、调试
**调试：调试是确定错误根本原因并因此纠正此错误的过程。**
> 调试不用于改进代码质量，而是诊断代码缺陷的一种方法。
- 缺陷(defects)理应是在`完全理解程序的功能`的情况下，那些`没有按照你既定的意愿`运行的`障碍物`。
- 在上述条件下，错误提供了以下一些方面的内容
  - 1.还需要进一步理解正在编写的程序。（理论上一个被透彻理解的程序不该有缺陷，即使有也应该早就被修正了）
  - 2.明确犯了哪一种类型的错误，是一个机会。（并不是每天都有聚光灯照着，将你的弱点照地一清二楚）
    - 为什么犯这样的错误？
    - 如何才能更快地发现这个错误？
    - 如何才能够预防这样的错误再次发生？
    - 代码中还有类似的错误吗？
    - 你能在这些错误造成麻烦之前改正它们吗？
    > 《软件工程规范》可以帮忙确定更容易犯哪些错误。
  - 3.从代码阅读者的角度分析代码质量（必须通过阅读代码，发现缺陷，这允许我们带着挑剔的眼光审视自己的代码）
    - 代码易读吗？
    - 它怎样才能更好？
    - 用你的结论重构你现在的代码，并让自己下次编写的代码更好。
  - 4.审视自己解决问题的方法
    - 1.调试解决问题方法使你感到`自信`吗？
    - 2.方法`管用`吗？
    - 3.能够很快地发现缺陷吗？
    - 4.你的方法是否导致调试的工作成效很差？
    - 5.调试过程中你有痛苦和挫败感吗？
    - 6.你是在胡乱猜测吗？
    - 7.你的调试方法需要改进吗？
    > 大量的项目在调试上花费了许多的时间，那么花点时间来分析并改进调试方法，这是减少程序开发时间的最有效方法。
  - 5.审视自己修正缺陷的方法
    - 是不是简单的包扎？治标不治本？还是从系统角度进行修正，通过精准的分析对问题的根本原因对症下药呢？
  > 调试是软件构建之路所交织的地方：可读性、设计、软件质量......  
  > 编写优秀的代码带来的回报，就是在精于此道时，无需频繁调试。

**调试的错误概念辨析**
- “凭猜测来找出缺陷”
- “不把时间浪费在理解问题上”
- “用最唾手可得的方式修正错误”-->简单包扎。
- “迷信式编程、调试”
  - ...

> 请正确认识编写的程序存在的问题，是人的问题，而不是计算机的，也不是编译器的，程序是自己写的，而自己要对此负责。
- 不正确的行为例子
  - 避免陷入尴尬的境地：在公众面前先职责别人犯了错，最终却发现错误其实由自己诞生。
> 出于自身的利益，将错误的产生与自己关联，这有利于我们的调试，发现错误。（参见上面：错误允许我们以挑剔的眼光看待自己的代码，这样的机会并不常有）

**23.2 寻找缺陷**
- 核心概念：（数据、假说、证明）loop
- 一种科学的调试方法
  - 1.通过`可重复`的试验收集数据。
  - 2.根据相关数据的统计，构造一个`假说`。
  - 3.设计一个实验来证明或反证这个假说。
  - 4.`证明或反证假说`。
  - 5.重复1~4步骤。
- 一种有效的寻找缺陷的方法
  - 1.将错误状态稳定下来。
	> 一些技巧说明
  - 2.确定错误的来源
	> 一些技巧说明
    - a) `收集`产生缺陷的相关数据
    - b) `分析`所收集的数据，并`构造对缺陷的假设`。
    - c) 确定如何去证实或者证伪这个假设，可以对程序进行测试或是通过检查代码。
    - d) 按照2c的方法对假设做出最终结论。
  - 3.修补缺陷
  - 4.对所修补的地方进行测试。
  - 5.查找是否还有类似的错误。
- 蛮力调试
- 语法错误
