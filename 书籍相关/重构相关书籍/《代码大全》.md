参考资料：

《代码大全》

# 打好基础

## 第1章、欢迎进入软件构件的世界
**构建的基本含义**
- 基本含义：建设的过程。
- 通常使用的含义：建设的过程中`动手的那一部分`。

**需要回答的问题**
- 1.什么是软件构建？（1.1标题）
  - 构建活动主要关注`编码与调试`，还有一些其他活动（详细设计、单元测试、集成测试等）
  > 使用`编程`来认识软件构建。（创造力、判断力）
- 2.构建的具体任务是什么？
  > **确认基础工作、设计如何测试、设计、编写、测试、评审、润饰、集成、优化**。
  - 确认构建活动的基础工作已经完成，可以进行构建活动。
  - 确定如何测试构建的代码。
  - 设计如何编写类、子程序
  - 创建并命名变量和具名常量
  - 选择控制结构（control structure），组织语句块
  - 对代码进行单元测试、集成测试，排除其中的错误
  - 评审
  - 润饰代码，进行代码的格式化与注释
  - 将单独开发的多个软件集为一体。
  - 调整代码（tuning code），令他更快，更节省资源。
- 3.基于什么，判断构建活动非常重要？
  > 主要，就是构建活动的唯一核心原因。
  - 构建活动是软件开发的主要组成部分（数据支撑 30% ~ 80%）
  - 构建活动是软件开发的核心活动（前：需求分析、架构设计。后：测试）
  - 对主要部分进行优化，提高效率。
  - 构建活动的产物————源代码，是对软件的唯一精确描述。（最新）
  - 构建活动是唯一确保会被完成的工作。（其他都是影响）
  - 构建活动对软件的质量有着实质性的影响。

## 第2章、用隐喻来更充分地理解软件开发
> 隐喻可以帮助我们清楚地理解软件开发的过程。
- 1.隐喻的重要性（2.1内容）
  - 使用隐喻的基本方式：建模。
    > 通过把不太理解的东西与较为理解的、且十分相似的东西作比较，那么就能够获取对不太理解的东西的深刻理解。
- 2.隐喻与算法的区别
  - 算法是可预测的、确定性的、不易变化的
    > 回顾算法定义：（来自算法导论）  
    > **算法**：定义良好的计算过程，通过一系列计算步骤用来将输入数据转化成输出结果。  
  - 隐喻更像是一种启发式的方法。区别在于————间接程度。
- 3.如何使用隐喻？
  - 理解2
  - 用来提高对编程问题和编程过程的洞察力
  - 用来帮助思考编程过程的活动
  - 想象出更好的做事情的方法
- 4.常见的软件隐喻
  - 写作：原创性。软件需要重用
  - 耕作，培植系统：每次做一点。（增量，但是软件不完全是增量）
  - 系统生长：增量的(incremental)、迭代的(iterative)、自适应的(adaptive)、演进的(evolutionary)。
    - 骨架、替换，依次增加。
  - 软件`建造`
    - 1.建造推倒重来的成本高。
    - 2.适当的多层次的规划对建造建筑物和构建软件都有好处。
  - 应用软件技术，智慧工具箱。
    - 把所有的技术、方法留在脑海里，在合适的时候拿来使用。
  > 隐喻是一种启发式方法，而不是算法，它只是一种帮助理解的工具。


## 第3章、三思而后行：前期准备
- 1.了解前期准备的重要性
  - 使用高质量的实践方法是那些能够创造高质量软件的程序员的共性

## 4.关键的“构建”决策

## 1-4章总结



# 创建高质量的代码
## 第6章、可以工作的类
类、ADT的定义，类和ADT的区别 参考 基础概念辨析.md
- 1.认识ADT与类，以下阐述ADT相关知识点
  - 好处
    - 隐藏实现细节
    - 改动不影响整个程序
    - 让接口提供更多信息
    - 容易提高程序性能
    - 让程序的正确性显而易见
    - 让程序更具自我说明性
    - 无需在程序内到处传递数据
    - 可以像在现实世界中那样操作实体，而不用在底层实现上操作它
  - 例子：字体定义
  - 指导建议
    - 把常见的数据类型创建为ADT并使用这些ADT
    - 把像文件这样的常用对象当成ADT
    - 简单的事务也可以当作ADT
    - 不要让ADT依赖于存储介质
  - 在非面向对象环境中使用ADT处理多份数据实例的三个方式
    - 使用ADT服务子程序明确指定实例（如fontId）
    - 明确地向ADT服务子程序提供所要用到的数据。
    - 使用隐含实例。
      - 比如：设计一个新的服务子程序，通过它让某个特定的字体实例成为当前实例。
      > 不推荐，系统范围内对状态的依赖，意味着需要用到字体操作时，所有代码需要跟踪当前的字体实例。
- 2.创建高质量的类
  > 第一步，也是最重要的一步，创建一个好的接口。  
  - 创建良好的接口
    - 隐含两个概念
      - 1.创建一个`可以通过接口来展现的合理的抽象`。
      - 2.并 确保`细节`被`隐藏`在抽象的背后。
    > 类的接口为实现细节提供了一种抽象，`这种抽象应该具有一致性`  (推导结论，由表现推导)。  
    > 表现为：能够提供一组明显相关的子程序。
    - 例子
      - 一个良好的抽象：雇员，一组获得雇员信息的方法。
      - 一个不良的抽象：程序，提供了各种各样的功能。
    - 指导意见
      - 类的接口应该展现一致的抽象层次
        - 一个类中 雇员抽象 + 列表抽象的例子
      - **一定要理解类所实现的抽象是什么**
        - 电子表格（150个子程序）、栅格控件（15个）
        - 使用包裹类（wrap class）隐藏“把电子表格控件用作栅格控件”这一事实。
      - 提供成对的服务
      - 把不相关的信息转移到其他类中
      - 尽可能让接口可编程，而不是表达语义（**这部分内容作为接口，放在基础概念辨析中**）
      - 谨防在修改时破坏接口的抽象
      - 不要添加与接口抽象不一致的公共成员
      - 同时考虑抽象性和内聚性（两个概念非常紧密）
        - 一个呈现出良好的抽象的类接口通常有很高的内聚性。
        - 而具有很高的内聚性的类往往也会成为很好的抽象（尽管这种关系不如前者那么强）。
     > 关注类的接口所表现出来的抽象，比关注类的内聚性更有助于深入地理解类的设计。如果觉得某个类的内聚性非常弱，也不知道怎么改，可以问问自己这个类是否表现出一致的抽象。
  - 良好的封装  
    > 封装和抽象的概念辨析，参考基础概念辨析.md。
    - 尽可能地限制类和成员的可访问性
      - 考虑`“采用哪种方式能最好地保护接口抽象的完整性”`。
    - 不要公开暴露成员数据
    - 避免把私用的实现细节放入类的接口中
      - 做到真正的封装后，程序员们应该看不到任何实现细节。（无论是字面上还是寓意上）
      - C++却从语言结构上要求程序员在类的接口中透露实现细节（在类的头文件可以看到private的变量，这鼓励程序员查阅实现细节）
      - Effective C++ 建议把类的接口和类的实现隔离开，并在类的声明中包含一个指针，让该指针指向类的实现，但不能包含其他任何细节。
    - 不要对使用者做出任何假设——除非接口有明确说明（参考接口的可编程部分、语义部分概念辨析）
    - 避免使用友元类(friend class)——破坏封装。
      - 正确的方式，如State模式中使用友元类有助于管理复杂度。
    - 不因为一个子程序里仅使用公用子程序，就把它归入公开接口。
    - 让阅读代码比编写代码更方便。
    - 要格外警惕从语义上破坏封装性。
      - 语法：设为private
      - 语义：某个函数被另外一个函数隐含调用。
    - 留意过于紧密的耦合关系
- 3.有关设计和实现的问题
  > 主要讨论 包含、继承、成员函数 和 数据成员 、类之间的耦合性、构造函数、值对象、引用对象。
  - 包含关系(has-a)
    - 使用包含实现has-a关系
    - 万不得已情况下使用private继承
      - 原因：让外层的包含类能够访问被包含类的protected成员函数与数据成员。
      - 其实也可以用其他方式解决。
    - 警惕7个以上的成员函数。（复杂考虑7-2，简单考虑7+2）
  - 继承关系（is-a）
    - public继承实现is-a关系
    - 要么使用继承并进行详细说明，否则不使用。
    - 遵循里氏替换原则（面向对象基本原则）
    - 确保继承只需要继承的那一部分。
  - 成员函数与数据成员
  - 构造函数
    - 如果可能，应该在所有的构造函数中初始化所有的数据成员。
      > 《重构》11.7，移除设值函数————清晰的表达对象不可变的意图。
    - 用私有构造函数来强制实现单件属性(single property)
    - 优先使用深层拷贝，除非论证可行，才使用浅层拷贝。
- 4.认识创建类的原因

## 第7章、高质量的子程序


## 第8章、防御式编程
防御式编程的主要思想：子程序应该不因传入的数据错误而被破坏，哪怕式由其他子程序产生的错误数据。
> 核心想法：承认程序都会有问题，都需要被修改，聪明的程序员应该根据这一点编写程序。  

> 如何面对严酷的非法数据的世界、在遇到“绝对不会发生”的事件以及其他程序员犯下的错误时，保护好你自己。  

> 应该自始自终考虑各种各样的错误处理机制，不应该由语言限制了自己。

**8.1 保护程序免遭非法输入数据破坏**
三种方法：
- 检查所有来源于外部的数据的值
- 检查子程序的所有输入参数的值
- 决定如何处理错误的输入数据
**8.2 断言**
1. 断言是用来做什么的？
   - 程序运行自检的代码
   - 断言是一种假定
2. 断言在什么时候使用？
   - 用错误处理代码来处理预期会发生的情况，用断言来处理绝不应该发生的状况
   - 执行的代码不要和断言一起使用（容易被排除在外，不编译）
3. 断言和错误处理技术是否可以同时使用？可以。
**8.3 错误处理技术**
**8.4 异常**
**8.5 隔离程序**
**8.6 辅助调试的代码**
**8.7 确定产品中保留多少防御式代码**
**8.8 对防御式编程采取防御的姿态**


---
## 第18章、表驱动法（Table-Driven Method）
**表驱动法的基本认知**：它是一种编程模式（schema），通过从表中查询数据，而不使用逻辑语句。
> 理论上所有能够使用逻辑语句来选择的事务，都可以通过查表来选择。


---
## 第23章、调试
**调试：调试是确定错误根本原因并因此纠正此错误的过程。**
> 调试不用于改进代码质量，而是诊断代码缺陷的一种方法。
- 缺陷(defects)理应是在`完全理解程序的功能`的情况下，那些`没有按照你既定的意愿`运行的`障碍物`。
- 在上述条件下，错误提供了以下一些方面的内容
  - 1.还需要进一步理解正在编写的程序。（理论上一个被透彻理解的程序不该有缺陷，即使有也应该早就被修正了）
  - 2.明确犯了哪一种类型的错误，是一个机会。（并不是每天都有聚光灯照着，将你的弱点照地一清二楚）
    - 为什么犯这样的错误？
    - 如何才能更快地发现这个错误？
    - 如何才能够预防这样的错误再次发生？
    - 代码中还有类似的错误吗？
    - 你能在这些错误造成麻烦之前改正它们吗？
    > 《软件工程规范》可以帮忙确定更容易犯哪些错误。
  - 3.从代码阅读者的角度分析代码质量（必须通过阅读代码，发现缺陷，这允许我们带着挑剔的眼光审视自己的代码）
    - 代码易读吗？
    - 它怎样才能更好？
    - 用你的结论重构你现在的代码，并让自己下次编写的代码更好。
  - 4.审视自己解决问题的方法
    - 1.调试解决问题方法使你感到`自信`吗？
    - 2.方法`管用`吗？
    - 3.能够很快地发现缺陷吗？
    - 4.你的方法是否导致调试的工作成效很差？
    - 5.调试过程中你有痛苦和挫败感吗？
    - 6.你是在胡乱猜测吗？
    - 7.你的调试方法需要改进吗？
    > 大量的项目在调试上花费了许多的时间，那么花点时间来分析并改进调试方法，这是减少程序开发时间的最有效方法。
  - 5.审视自己修正缺陷的方法
    - 是不是简单的包扎？治标不治本？还是从系统角度进行修正，通过精准的分析对问题的根本原因对症下药呢？
  > 调试是软件构建之路所交织的地方：可读性、设计、软件质量......  
  > 编写优秀的代码带来的回报，就是在精于此道时，无需频繁调试。

**调试的错误概念辨析**
- “凭猜测来找出缺陷”
- “不把时间浪费在理解问题上”
- “用最唾手可得的方式修正错误”-->简单包扎。
- “迷信式编程、调试”
  - ...

> 请正确认识编写的程序存在的问题，是人的问题，而不是计算机的，也不是编译器的，程序是自己写的，而自己要对此负责。
- 不正确的行为例子
  - 避免陷入尴尬的境地：在公众面前先职责别人犯了错，最终却发现错误其实由自己诞生。
> 出于自身的利益，将错误的产生与自己关联，这有利于我们的调试，发现错误。（参见上面：错误允许我们以挑剔的眼光看待自己的代码，这样的机会并不常有）

**23.2 寻找缺陷**
- 核心概念：（数据、假说、证明）loop
- 一种科学的调试方法
  - 1.通过`可重复`的试验收集数据。
  - 2.根据相关数据的统计，构造一个`假说`。
  - 3.设计一个实验来证明或反证这个假说。
  - 4.`证明或反证假说`。
  - 5.重复1~4步骤。
- 一种有效的寻找缺陷的方法
  - 1.将错误状态稳定下来。
	> 一些技巧说明
  - 2.确定错误的来源
	> 一些技巧说明
    - a) `收集`产生缺陷的相关数据
    - b) `分析`所收集的数据，并`构造对缺陷的假设`。
    - c) 确定如何去证实或者证伪这个假设，可以对程序进行测试或是通过检查代码。
    - d) 按照2c的方法对假设做出最终结论。
  - 3.修补缺陷
  - 4.对所修补的地方进行测试。
  - 5.查找是否还有类似的错误。
- 蛮力调试
- 语法错误
