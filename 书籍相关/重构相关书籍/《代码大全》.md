参考资料：

《代码大全》

--- 
# 第一部分、打好基础
## 第1章、欢迎进入软件构建的世界
> 关键词：创造力、必不可少
**核心目标**
- 理解`构建`是什么？
  - [构建的基本含义是什么](###构建的基本含义)
  - [**所有软件工程中的活动** 与 **构建活动** 之间的关系](###构建活动与软件开发过程中的活动的关系)
  - [构建活动中的具体任务有哪些？](###构建活动的具体任务)
- 掌握构建具有哪些特点？
  - [构建的特点](###构建活动的特点)
- 为什么要在软件开发过程中特别强调构建？
  - [为什么构建非常重要？](###为什么构建活动非常重要？)
- 总结（分布在各个链接的开头，参考了《代码大全》最后的总结，跟几次读文章最后的结果一致）
  > 最后，你对“如何进行构建”的理解程度，决定了你这名程序员的优秀程度————这就是本书其余部分的主题了。

### 构建的基本含义
- 基本含义：建设的过程。
- 通常使用的含义：建设的过程中`动手的那一部分`。

### 构建活动与软件开发过程中的活动的关系
> 构建的主要活动包括：详细设计、编码与调试、集成、开发者测试（developing testing）（包括单元测试和集成测试）
- 软件开发过程中的活动， 构建的主要内容（⭐表示）
  - 定义问题
  - 需求分析
  - 规划构建
  - 软件架构、高层设计
  - 详细设计 ⭐
  - 编码和调试 ⭐⭐⭐⭐⭐
  - 单元测试 ⭐
  - 集成测试 ⭐
  - 集成
  - 系统测试
  - 保障维护

### 构建活动的具体任务
- **确认基础工作、设计如何测试、设计、编写、测试、评审、润饰、集成、优化**。
  - 确认构建活动的基础工作已经完成，可以进行构建活动。
  - 确定如何测试构建的代码。
  - 设计如何编写类、子程序
  - 创建并命名变量和具名常量
  - 选择控制结构（control structure），组织语句块
  - 对代码进行单元测试、集成测试，排除其中的错误
  - 评审
  - 润饰代码，进行代码的格式化与注释
  - 将单独开发的多个软件集为一体。
  - 调整代码（tuning code），令他更快，更节省资源。

### 构建活动的特点
> 构建通常被称作“编码”和“编程”
- 编码、编程
  - 编码的意味：把已经存在的设计机械化地翻译成计算机语言。
- 构建并不都是机械化的，它需要`可观的创造力和判断力`。

### 为什么构建活动非常重要？
> 1.软件构件是软件开发的核心活动；构件活动是每个项目中唯一必不可少的工作。  
> 2.构建活动的质量对软件的质量有着实质性的影响。
- 构建活动是软件开发的主要组成部分（数据支撑 30% ~ 80%）
- 构建活动是软件开发的核心活动（前：需求分析、架构设计。后：测试）
- 对主要部分进行优化，提高效率。
- 构建活动的产物————源代码，是对软件的唯一精确描述。（最新）
- 构建活动是唯一确保会被完成的工作。（其他都是影响） ⭐⭐⭐⭐⭐
- 构建活动对软件的质量有着实质性的影响。⭐⭐⭐⭐

## 第2章、用隐喻来更充分地理解软件开发
> 关键词：建筑、贴切的隐喻
**核心目标**
- 隐喻
  - [隐喻和使用隐喻](###隐喻和使用隐喻)
  - [掌握隐喻的优点和缺点以及特点](###隐喻的优点与缺点以及特点)
    > 有些隐喻比其他一些隐喻更加贴切。
  - [用什么样的心态看待隐喻](###用什么样的心态看待隐喻)
- [常见的软件隐喻](###常见的软件隐喻)
  > 建议先看常见的软件隐喻，然后再看软件隐喻
- [软件隐喻](###隐喻与软件隐喻)
  - > 使用和算法对比的方式更好地理解软件隐喻。  
  - > 隐喻在软件开发领域与其他熟悉的活动联系在一起，能帮助更好的理解软件开发的过程。  
  - > 软件的构建与房屋的建设告诉我们，准备是必要的，而大项目与小项目之间也是有差异的。
- [使用隐喻的思想](###使用隐喻的思想)
  - > 每位程序员都有许多工具，但并不存在任何一个能够适用于所有工作的工具，因地制宜的选择正确的工具是能有效编程的程序员的关键。
  - > 不同的隐喻之间并不排斥，应当使用对你最有益处的某种隐喻组合。

### 隐喻和使用隐喻
- 隐喻是一系列比喻，或者模型，用于类比你所希望理解的事物。
- 建模是使用隐喻的一种方式，通过把一些不太理解的东西和一些较为理解的、且十分类似的东西作比较，这样一来可以对不太理解的东西产生更深刻的理解。
- 模型的最大功力在于生动性，能够把握整个概念，隐隐约约暗示各种属性、关系，以及一系列需要补充查证的部分。

### 隐喻的优点与缺点以及`特点`
- [优点](###隐喻和使用隐喻)
- 缺点
  - 隐喻的概念被过度引申时，模型可能将人引入歧途。
- 特点
  - 使用不同的隐喻可以解释不同的问题，可以对问题有着不同的理解。
  - 隐喻并没有错误与正确之分，只有不是很贴切的隐喻和更贴切的隐喻。
    > 科学发展的历史并不是一系列从“错误”的隐喻到“正确”的隐喻的转变，而是一系列从“不太合适”的隐喻到“更好”的隐喻的转变，也是从`不是很贴切的隐喻`到`更贴切的隐喻`的转变，还是从在`一个方面暗示人们`到在`另一个方面暗示人们`的转变。
  - 类比参考：[科学方法的收集数据、提出假说、验证假说的循环](../../通用知识/3.科学方法.md)

### 用什么样的心态看待隐喻
- [心态](###隐喻的优点与缺点以及特点)：查看隐喻的特点的第二段。

### 隐喻与软件隐喻
- [隐喻参考](###隐喻和使用隐喻)
- 软件隐喻与算法对比来了解软件隐喻
  - 算法是一套定义明确的指令，使你能完成某个特定的任务。
    - 算法是可预测的、确定性的、不易变化的
    - 交叉参考：[算法基本定义](../../计算机基础知识相关/算法/1_2_算法入门.md#算法的基本定义)
  - 启发式方法（试探法）是帮助寻求答案的技术。
- 编程最大的挑战：将问题概念化。
  - 编程中的很多问题都是概念性的错误，每一个问题的概念都是独特的，找到一套能够解决所有问题的指导原则是困难的。所以，能一般性的知道大致如何解决问题，至少也和知道如何解决特定问题一样有价值了。
- 使用软件隐喻
  - 使用软件隐喻，应该通过它来提高你对编程问题和编程过程的洞察力；用它来帮助你思考编程过程中的活动，想象出更好的做事情的方法。
  - 你不可能看到一行代码说它违反了本章所描述的某个隐喻。但随着时间的流逝，人们会发现，相对于不善运用隐喻的人来说，那些使用隐喻来照亮自己软件开发过程的人，他们对于编程的理解会更好，并且能够更快地写出更好的代码。

### 常见的软件隐喻
- 写作
  - 特点：不需要正规地做计划，写出来就是了。注重`原创性`。
  - 软件开发的特点：`重用性`
- 耕作、培植系统
  - 特点：增量
    > 开始贴近软件开发的特点了，即增量。
  - 缺点：耕作的管理对象是土地，而不是果子，不够贴切。
- 系统生长（牡蛎养殖）：
  - 特点：`增量的(incremental)`、迭代的(iterative)、自适应的(adaptive)、演进的(evolutionary)。
    > 更加贴切了
  - 软件开发的类比：骨架、替换，依次增加。
- 建筑，软件`建造`
  - 特点
    - 1.建造推倒重来的成本高。
    - 2.适当的多层次的规划对建造建筑物和构建软件都有好处。
    - 3.现成的工具。
    - 4.特别的定制。
    - 5.获益于精心计划。
  - 交叉参考：[软件开发的流程参考](###构建活动与软件开发过程中的活动的关系)
  - 交叉参考：[构建活动的具体任务参考](###构建活动的具体任务)
    - 建筑什么样的房子————问题定义
    - 探讨建筑的总体设计————软件架构
    - 画出详细的蓝图（有一个承包人）————详细设计
    - 准备好建造地点，打好地基，搭建房屋框架，砌好墙壁，盖房顶，通水、电、煤...——————构建过程
    - 美化房屋————优化（评审、润饰、调整）、集成、保障维护
  - 其他
    - 工具
      - 软件的组件、预先制作好的家电、墙砖...
    - 定制化
      - 软件的定制化组件、定制化的家具
    - 精心计划
      - 房屋获益于此
      - 软件开发也获益于此（不同的软件开发方法）
    - 留有余地
      - 建筑留有余地
      - 软件留有余地。
  - 一些建筑领域的软件术语延申
    - 软件架构（建筑学，architecture）、支撑性代码（脚手架，scaffolding）、构建（建设，construction）、基础类（foundation classes）、以及分离代码（tearing code apart）
- 应用软件技术，智慧工具箱。
  - 把所有的技术、方法留在脑海里，在合适的时候拿来使用。

### 使用隐喻的思想
- 交叉参考：[常见的软件隐喻](###常见的软件隐喻)
- 组合思想：多个隐喻可以互相组合，达到更好的效果。

## 第3章、三思而后行：前期准备
> 主要重点：构建开始前，你应该做什么？
> 关键词：准备工作、裁剪、周全
**核心目标**
- 1.前期准备的含义、目的、原因、重要性。
  - 前期准备是做什么？
  - 前期准备的目的是什么？
  - 为什么要做前期准备？
  - 如果不做前期准备会怎么样？
  - 前两点：重要性。
- 2.衡量前期准备的方式。
  - 一个基本的标准。
  - 前期准备的程度：两种方法。
  - 两种方法的优缺点。
  - 一个容易出现的误区。

- 尝试总结
  - 前期准备指的是“在工作开始之前，应该做的一些准备工作”。它的目的是降低风险，尽可能地让工作平稳地进行。
  - 如果一个工作，没有做好准备工作，就有可能发生一些意外，包括不限于浪费更多的时间、精力做错误的事情，导致延误，导致无法完成任务。
  - 对软件领域来说，不同阶段的准备工作是不一样的，并且准备工作对软件领域很重要，这一重要性体现在第二点。（任何领域都一样）
  - 对一个技术人员来说，培训周围的非技术人员是非常重要的事情，可以通过诉诸逻辑（前期准备可以避免浪费时间在不重要的事情上），诉诸类比（建筑行业建造房屋需要蓝图），诉诸数据（对比说明准备工作的重要性），来与其他职能人员沟通。
  - 判断前期准备工作是否完成，可以通过基本的判断“我已经非常详细地研究了需求和设计，我想不出在编码和调试期间还会遇到什么大的问题”来判断。
  - 是否需要前期准备工作取决于从事软件的类型（工作的类型），适度地对前期准备进行裁剪是必要的。
  - 针对以上一点，通常地开发方式为序列式开发与迭代式开发。
  - 我们要认清迭代式开发能够“减少”**前期准备的不足**，但不能根治这个问题。
  - 迭代式开发与序列式开发存在一定的区别，与不同。有着不同的特点。
  - 可以根据项目来决定适度采取不同的开发方式。
  - 一条经验告诉我们：计划%80，为其他需求预留时间。或者%20，迭代详细说明。是不错的。
- [前期准备的重要性](###前期准备的重要性)

- 2.了解如何判定“是否已经准备好开始构建工作”了
- 在开始构建之前要做前期准备的绝对有力且简明的论据
  - 理解，这个系统应该做什么？它应该如何做到这些？
  - 一部份工作：培训周围的非技术人员，讲解开发过程。

### 前期准备的重要性
> 使用高质量的实践方法是那些能够**创造高质量软件**的程序员的共性
- 项目前期、中期、末期强调质量
  - 末期：强调系统测试
  - 中期：构建实践 ⭐⭐⭐⭐
  - 前期：计划、要求并且设计一个高质量的产品。
- 准备工作的中心目标：**降低风险**
  - 一个好的项目规划者能够尽可能早地将主要的风险清除掉，以使项目的大部分工作能够**尽可能平稳地进行**。
  - 目前软件开发中最常见的**项目风险**是：**糟糕的需求分析**和**糟糕的项目计划**，因此准备工作就倾向于**改进需求分析**和项目规划。
- 其他：
  - 事先做好计划，能够避免许多压力。

### 培训周围的非技术人员是我们的职责
> 开发过程的恳谈需要一些技巧
- 诉诸逻辑
  > 制作这个系统之前，需要思考如何去做，这非常重要。
  > 因为我们**不希望花费很多的时间和金钱（核心逻辑）**，却毫无必要地走进死胡同。
  > --> 做前期准备工作，能够降低风险，减少花费的额外成本（我的、策划的）。
  - 管理角度：项目所用时间、人数、计算机台数（即项目资源）
  - 技术角度：想要建造什么？避免浪费钱和精力制作错误的东西。
  - 例子：
    - 功能单——“盲盒小铺”的制作过程的错误梳理。
      - 盲盒小铺需求梳理
        - 1.在热销中添加一个页签，显示盲盒小铺界面。（已分析）
        - 2.该界面需要足够通用，满足以下一些要求
          - 1.界面的背景、标题、展示可配置。（已分析）
          - 2.界面的商品售卖、礼包售卖可配置。（已分析）
          - 3.商品支持赠礼，礼包支持赠礼。（已分析）
          - 4.礼包包含多个道具，部分拥有情况如何处理。（⭐缺少沟通）
          - 5.背景颜色、背景渐变色配置。（⭐没有仔细研究）
        - 3.支持预览、活动说明。（已分析）
        - 4.UI动效、额外需求
          - 1.左右滑动到底部播放特定动效。（⭐没注意看）
          - 2.点击右侧可滑到底部。（⭐没注意看）
          - 3.单个商品居中显示，五个以上可以滑动（并在左侧显示）（已分析）
          - 4.礼包居中显示，礼包个数影响。（已分析）
          - 5.礼包内容2~4个不同展现效果（⭐⭐后续才知道）
        - 5.隐藏需求
          - 1.购买后的刷新（已分析）
          - 2.可能存在的跳转问题（⭐已分析，但是没有探究原因，试图测试时候看看情况）
          - 3.商城、购买界面的获取途径配置问题，希望导到热销。（⭐未沟通）
          - 4.货币需要单独配置（⭐未分析，编写时发现）
      - 优点：
        - 1.分析了绝大部分内容，单子上的障碍大都排除。
        - 2.采用了测试数据进行分析处理。
      - 缺点：
        - 1.设计了配表，但未考虑策划对旧表的一个眷恋问题。
        - 2.策划没有时间做沟通。
        - 3.线上沟通不畅。
        - 4.box等问题没有留下记录，而是重复询问，浪费了大量时间。
- 诉诸类比
  - 为什么需要做技术规划？
    - 因为建造房屋需要准备好草图，浇筑混凝土之前必须审核蓝图并批准，软件也需要做技术规划。
  - 为什么需要按照正确的顺序去做？
    - 因为在圣诞树立起来之前，你不会对它做装饰；打开烟囱前，你不会生火；不会长途旅行前，油箱是空的；也不会在穿袜子前穿鞋；软件领域也必须按照正确的顺序做事情。
  - 为什么需要准备？
    - 因为如果施工人员准备不充分，很有可能在建造过程中因为“需要在某所已经建造好的房子下面挖一条下水道”而延误。
    > 盲盒小铺因为需要支持跳转途径分化，可能导致延期。
- 诉诸数据
  - 引入缺陷 和 找到缺陷的时间 与 修复缺陷的费用 之间的关系。
### 前期准备的目标
- 我们最好立刻开始编码，因为将会有很多的调试工作需要做
- 我们并没有为测试安排太多的时间，因为将来不会发现多少缺陷
- 我们已经非常详细地研究了需求和设计，我想不出来编码和调试期间还会遇到什么大问题。⭐⭐⭐⭐⭐（目标）


## 第4章、关键的“构建”决策
> 主要关键点：程序员或技术带头人（直接或间接）负责的准备工作，即手推车中的工具在软件中的等价物。
- 1.编程语言：编程语言的选择从多个方面影响生产率和代码质量。
- 2.编程约定
  - “架构概念的完整性” 与 “其底层实现” 的关系
    - **“实现”** 必须与（指导该实现的）**“架构”** `保持一致`，而且这种一致性是内在的、固有的。
    - 这正是变量名称、类的名称、子程序名称、格式约定、注释约定等针对“构建活动”的指导方针的**关键所在**。
  - 编码约定的细节的精确度
    - 在编写完软件后，几乎不可能改变（翻新）软件所遵循的编码约定。
- 3.在技术浪潮中的位置（了解不同阶段的背景）
  - 前期、中期、末期（丰富的软件开发基础设施的背景）
  - **“在一种语言上编程” 与 “深入一种语言去编程”**
    - 前者：思想限制于语言支持的那些构件。
    - 后者：决定表达的思想是什么，然后如何使用特定语言提供的工具来表达这些思想。
    > 大多数重要的编程原则不依赖于特定的语言，而依赖于你使用语言的方式。如果你使用的语言缺乏你希望用的构件，或者倾向于出现其他种类的问题，那就应该试着去弥补它。发明你自己的编码约定、标准、类库及其他改进措施。
- 4.主要的构建实践方法————？？？
  - 编码
  - 团队工作
  - 质量保证
  - 工具

## 1-4章总结


---

# 第二部分、创建高质量的代码
## 第5章、软件构件中的设计


## 第6章、可以工作的类
[ADT与类概念参考](../../计算机基础知识相关/概念知识/基础概念辨析.md#adt%E4%B8%8E%E7%B1%BB)
- 1.认识ADT与类，以下阐述ADT相关知识点
  - 好处
    - 隐藏实现细节
    - 改动不影响整个程序
    - 让接口提供更多信息
    - 容易提高程序性能
    - 让程序的正确性显而易见
    - 让程序更具自我说明性
    - 无需在程序内到处传递数据
    - 可以像在现实世界中那样操作实体，而不用在底层实现上操作它
  - 例子：字体定义
  - 指导建议
    - 把常见的数据类型创建为ADT并使用这些ADT
    - 把像文件这样的常用对象当成ADT
    - 简单的事务也可以当作ADT
    - 不要让ADT依赖于存储介质
  - 在非面向对象环境中使用ADT处理多份数据实例的三个方式
    - 使用ADT服务子程序明确指定实例（如fontId）
    - 明确地向ADT服务子程序提供所要用到的数据。
    - 使用隐含实例。
      - 比如：设计一个新的服务子程序，通过它让某个特定的字体实例成为当前实例。
      > 不推荐，系统范围内对状态的依赖，意味着需要用到字体操作时，所有代码需要跟踪当前的字体实例。
- 2.创建高质量的类
  > 第一步，也是最重要的一步，创建一个好的接口。  
  - 创建良好的接口
    - 隐含两个概念
      - 1.创建一个`可以通过接口来展现的合理的抽象`。
      - 2.并 确保`细节`被`隐藏`在抽象的背后。
    > 类的接口为实现细节提供了一种抽象，`这种抽象应该具有一致性`  (推导结论，由表现推导)。  
    > 表现为：能够提供一组明显相关的子程序。
    - 例子
      - 一个良好的抽象：雇员，一组获得雇员信息的方法。
      - 一个不良的抽象：程序，提供了各种各样的功能。
    - 指导意见
      - 类的接口应该展现一致的抽象层次
        - 一个类中 雇员抽象 + 列表抽象的例子
      - **一定要理解类所实现的抽象是什么**
        - 电子表格（150个子程序）、栅格控件（15个）
        - 使用包裹类（wrap class）隐藏“把电子表格控件用作栅格控件”这一事实。
      - 提供成对的服务
      - 把不相关的信息转移到其他类中
      - 尽可能让接口可编程，而不是表达语义（**这部分内容作为接口，放在基础概念辨析中**）
      - 谨防在修改时破坏接口的抽象
      - 不要添加与接口抽象不一致的公共成员
      - 同时考虑抽象性和内聚性（两个概念非常紧密）
        - 一个呈现出良好的抽象的类接口通常有很高的内聚性。
        - 而具有很高的内聚性的类往往也会成为很好的抽象（尽管这种关系不如前者那么强）。
     > 关注类的接口所表现出来的抽象，比关注类的内聚性更有助于深入地理解类的设计。如果觉得某个类的内聚性非常弱，也不知道怎么改，可以问问自己这个类是否表现出一致的抽象。
  - 良好的封装  
    > 封装和抽象的概念辨析，参考基础概念辨析.md。
    - 尽可能地限制类和成员的可访问性
      - 考虑`“采用哪种方式能最好地保护接口抽象的完整性”`。
    - 不要公开暴露成员数据
    - 避免把私用的实现细节放入类的接口中
      - 做到真正的封装后，程序员们应该看不到任何实现细节。（无论是字面上还是寓意上）
      - C++却从语言结构上要求程序员在类的接口中透露实现细节（在类的头文件可以看到private的变量，这鼓励程序员查阅实现细节）
      - Effective C++ 建议把类的接口和类的实现隔离开，并在类的声明中包含一个指针，让该指针指向类的实现，但不能包含其他任何细节。
    - 不要对使用者做出任何假设——除非接口有明确说明（参考接口的可编程部分、语义部分概念辨析）
    - 避免使用友元类(friend class)——破坏封装。
      - 正确的方式，如State模式中使用友元类有助于管理复杂度。
    - 不因为一个子程序里仅使用公用子程序，就把它归入公开接口。
    - 让阅读代码比编写代码更方便。
    - 要格外警惕从语义上破坏封装性。
      - 语法：设为private
      - 语义：某个函数被另外一个函数隐含调用。
    - 留意过于紧密的耦合关系
- 3.有关设计和实现的问题
  > 主要讨论 包含、继承、成员函数 和 数据成员 、类之间的耦合性、构造函数、值对象、引用对象。
  - 包含关系(has-a)
    - 使用包含实现has-a关系
    - 万不得已情况下使用private继承
      - 原因：让外层的包含类能够访问被包含类的protected成员函数与数据成员。
      - 其实也可以用其他方式解决。
    - 警惕7个以上的成员函数。（复杂考虑7-2，简单考虑7+2）
  - 继承关系（is-a）
    - public继承实现is-a关系
    - 要么使用继承并进行详细说明，否则不使用。
    - 遵循里氏替换原则（面向对象基本原则）
    - 确保继承只需要继承的那一部分。
  - 成员函数与数据成员
  - 构造函数
    - 如果可能，应该在所有的构造函数中初始化所有的数据成员。
      > 《重构》11.7，移除设值函数————清晰的表达对象不可变的意图。
    - 用私有构造函数来强制实现单件属性(single property)
    - 优先使用深层拷贝，除非论证可行，才使用浅层拷贝。
- 4.认识创建类的原因

## 第7章、高质量的子程序


## 第8章、防御式编程
防御式编程的主要思想：子程序应该不因传入的数据错误而被破坏，哪怕式由其他子程序产生的错误数据。
> 核心想法：承认程序都会有问题，都需要被修改，聪明的程序员应该根据这一点编写程序。  

> 如何面对严酷的非法数据的世界、在遇到“绝对不会发生”的事件以及其他程序员犯下的错误时，保护好你自己。  

> 应该自始自终考虑各种各样的错误处理机制，不应该由语言限制了自己。

**8.1 保护程序免遭非法输入数据破坏**
三种方法：
- 检查所有来源于外部的数据的值
- 检查子程序的所有输入参数的值
- 决定如何处理错误的输入数据
**8.2 断言**
1. 断言是用来做什么的？
   - 程序运行自检的代码
   - 断言是一种假定
2. 断言在什么时候使用？
   - 用错误处理代码来处理预期会发生的情况，用断言来处理绝不应该发生的状况
   - 执行的代码不要和断言一起使用（容易被排除在外，不编译）
3. 断言和错误处理技术是否可以同时使用？可以。
**8.3 错误处理技术**
**8.4 异常**
**8.5 隔离程序**
**8.6 辅助调试的代码**
**8.7 确定产品中保留多少防御式代码**
**8.8 对防御式编程采取防御的姿态**


## 第9章、伪代码编程过程

---

## 第14章、组织直线型代码
- 必须有明确顺序的语句
  - 设法组织代码，使依赖关系变得非常明显。（命名、initialize、do）
  - 使子程序名能凸显依赖关系
  - 利用子程序参数明确显示依赖关系
    - 方法1：同一份数据依次往下调用。
    - 方法2：后一次使用的数据是前一次数据的返回值。
    - 方法3：不同数据，最后一次全部使用。（前面无依赖、后面有依赖）
  - 使用注释对顺序代码说明
  - 用断言或者错误处理代码来检查依赖关系
    - 标记变量：is_initialized
    - 缺点：带来额外复杂度。（比如init_flag之类的）
- 顺序无关的语句
  - 就近原则：把相关的操作放在一起
  - 使代码易于自上而下地阅读
  - 把相关的语句组织在一起


## 第15章、使用条件语句
> **重要提醒**：各种控制结构并不是生来平等的。请为代码的每一个部分选用最合适的控制结构。
> 要点：主次有序（条件的主次、处理的主次）、清晰（、准确（off-by-one、bool替代、每一个分支）。
- [if语句的指导原则](###if语句的指导原则)
  > if-then语句遵循一定的原则，可以使代码结构更清晰，降低理解的复杂度。
  > if放置正确的代码，能够让代码能够符合直觉，便于理解。
  > 条件需要足够清晰，并且不要弄反。
  - 以if语句为主，语句内容足够清晰，将主干沿着if行走即可。
- [if-then-else-if语句串指导原则](###if-then-else-Chain的指导原则)

### if语句的指导原则 
- 1.首先写正常代码路径；再处理不常见的情况。⭐⭐⭐⭐⭐
- 2.确保对于**等量**的分支是正确的 ⭐⭐⭐
  - 不要使用 `>` 代替 `>=` 或 用 `<` 代替 `<=`
  - off-by-one偏差问题
- 3.把正常情况的处理放在if后面，而不要放在else后面 ⭐⭐⭐⭐⭐
  - 指导原则：把决策的结果代码尽可能靠近决策位置的一般原则。
	> 在满足3指导原则的情况下，可以通过if条件测试的主流程来找到正常的情况，这一修改使人的注意力集中到了阅读代码的主流程上，而不是费力的去理解异常处理情况，因此整体代码更加容易阅读。嵌套条件语句的下部**积累了全部的错误情况**是良好的错误处理代码的一个标识。
- 4.让if后面跟有意义的语句
- 5.考虑else子句。
- 6.测试else句子的正确性。
- 7.检查if和else是不是弄反了。

### if-then-else-Chain的指导原则
- 1.检测串可以利用bool函数简化复杂的检测。
- 2.把最常见的情况放在最前面。
- 3.确保所有的情况都考虑到了
- 4.如果语言支持，请改为其他结构。
- case语句
- 选择有效的排序
  - 1.按字母或者数字顺序排序
  - 2.正常情况放在前面
  - 3.按照执行频率排序
- 其他诀窍
  - 简化每种情况的操作
  - 不要为了case语句制造变量
  - default语句仅用于检查真正的默认情况
    - default会失去case语句带来的说明功能
    - default会失去检测错误的能力
- 使用default子句检测错误
- 其他：C++和Jave在case尾部添加break或者添加注释，明确表示穿越执行的流程（避免越过）

## 第19章、循环控制
> 知道如何以及何时使用每一种循环是创建高质量软件的一个决定性因素。
> 利用程序获取到足够的信息。
- 循环种类：计数循环、连续求值的循环、无限循环、迭代器循环。
- 关注点：灵活度、检查位置（可能产生half-loop）。
- 避免错误的half-loop
- while loop（开头检查、结尾检查）
- loop with exit（终止条件出现在循环中间的）
  - 尽可能将所有退出循环的条件写在一起
  - 可以采用注释辅助说明
- for循环（固定次数，足够简单）⭐⭐⭐⭐⭐
  > for循环的关键之处在于，你在循环头处把它写好后就可以忘掉它了，无需在循环的内部做任何事情去控制它，如果存在一个必须使执行从循环中跳出的条件，那么就应该改用while循环。
- foreach循环（好处，避免循环内务处理算术问题）

### 让循环控制易理解
- 循环结构：进入循环、循环体、退出循环
- 循环注意点：检查端点
  - 进入循环：只从一个位置进入，初始化代码放在前面，while(True)作为无限循环，使用for，while有特定的使用范围
    - for的特点：初始化、结尾控制循环、循环条件，均在一行。
    - 重点：for和while的使用 ⭐⭐⭐⭐⭐
- 技巧
  - while黑盒理论。（while-break会破坏黑盒）
- 


## 第18章、表驱动法（Table-Driven Method）
**表驱动法的基本认知**：它是一种编程模式（schema），通过从表中查询数据，而不使用逻辑语句。
> 理论上所有能够使用逻辑语句来选择的事务，都可以通过查表来选择。


---
## 第23章、调试
**调试：调试是确定错误根本原因并因此纠正此错误的过程。**
> 调试不用于改进代码质量，而是诊断代码缺陷的一种方法。
- 缺陷(defects)理应是在`完全理解程序的功能`的情况下，那些`没有按照你既定的意愿`运行的`障碍物`。
- 在上述条件下，错误提供了以下一些方面的内容
  - 1.还需要进一步理解正在编写的程序。（理论上一个被透彻理解的程序不该有缺陷，即使有也应该早就被修正了）
  - 2.明确犯了哪一种类型的错误，是一个机会。（并不是每天都有聚光灯照着，将你的弱点照地一清二楚）
    - 为什么犯这样的错误？
    - 如何才能更快地发现这个错误？
    - 如何才能够预防这样的错误再次发生？
    - 代码中还有类似的错误吗？
    - 你能在这些错误造成麻烦之前改正它们吗？
    > 《软件工程规范》可以帮忙确定更容易犯哪些错误。
  - 3.从代码阅读者的角度分析代码质量（必须通过阅读代码，发现缺陷，这允许我们带着挑剔的眼光审视自己的代码）
    - 代码易读吗？
    - 它怎样才能更好？
    - 用你的结论重构你现在的代码，并让自己下次编写的代码更好。
  - 4.审视自己解决问题的方法
    - 1.调试解决问题方法使你感到`自信`吗？
    - 2.方法`管用`吗？
    - 3.能够很快地发现缺陷吗？
    - 4.你的方法是否导致调试的工作成效很差？
    - 5.调试过程中你有痛苦和挫败感吗？
    - 6.你是在胡乱猜测吗？
    - 7.你的调试方法需要改进吗？
    > 大量的项目在调试上花费了许多的时间，那么花点时间来分析并改进调试方法，这是减少程序开发时间的最有效方法。
  - 5.审视自己修正缺陷的方法
    - 是不是简单的包扎？治标不治本？还是从系统角度进行修正，通过精准的分析对问题的根本原因对症下药呢？
  > 调试是软件构建之路所交织的地方：可读性、设计、软件质量......  
  > 编写优秀的代码带来的回报，就是在精于此道时，无需频繁调试。

**调试的错误概念辨析**
- “凭猜测来找出缺陷”
- “不把时间浪费在理解问题上”
- “用最唾手可得的方式修正错误”-->简单包扎。
- “迷信式编程、调试”
  - ...

> 请正确认识编写的程序存在的问题，是人的问题，而不是计算机的，也不是编译器的，程序是自己写的，而自己要对此负责。
- 不正确的行为例子
  - 避免陷入尴尬的境地：在公众面前先职责别人犯了错，最终却发现错误其实由自己诞生。
> 出于自身的利益，将错误的产生与自己关联，这有利于我们的调试，发现错误。（参见上面：错误允许我们以挑剔的眼光看待自己的代码，这样的机会并不常有）

**23.2 寻找缺陷**
- 核心概念：（数据、假说、证明）loop
- 一种科学的调试方法
  - 1.通过`可重复`的试验收集数据。
  - 2.根据相关数据的统计，构造一个`假说`。
  - 3.设计一个实验来证明或反证这个假说。
  - 4.`证明或反证假说`。
  - 5.重复1~4步骤。
- 一种有效的寻找缺陷的方法
  - 1.将错误状态稳定下来。
	> 一些技巧说明
  - 2.确定错误的来源
	> 一些技巧说明
    - a) `收集`产生缺陷的相关数据
    - b) `分析`所收集的数据，并`构造对缺陷的假设`。
    - c) 确定如何去证实或者证伪这个假设，可以对程序进行测试或是通过检查代码。
    - d) 按照2c的方法对假设做出最终结论。
  - 3.修补缺陷
  - 4.对所修补的地方进行测试。
  - 5.查找是否还有类似的错误。
- 蛮力调试
- 语法错误
