参考书籍：

《重构》——改善既有代码的设计


**第三次阅读重构时，思考到的细节：**重构的过程，是如何诞生的？  
> 书中提到的重构16字心法的总结（不一定对，但是很符合我第三次阅读的感觉）：旧的不变、新的创建、一步切换、旧的再见。


# 2 重构的原则
- 2.1 何谓重构（refractor）
  - 名词定义：对软件内部结构的`一种调整`，目的是在`不改变软件可观察行为`的前提下，提高其可理解性，降低其修改成本。
  - 动词定义：使用一系列重构手法，在`不改变软件可观察行为`的前提下，`调整其结构`。
  > 名词介绍：restructuring（结构调整）。
  - 其他：与性能优化的区别
    - 性能优化的目的：使程序运行地更快。
    - 重构的目的：使得代码更容易理解，更容易被修改。

## 7.封装
交叉参考：[封装](../../计算机基础知识相关/概念知识/基础概念辨析.md#封装)

- 封装记录（7.1）
  - 为什么要封装记录？
  - 记录有什么优点，又有哪些缺点？
  - 怎么样弥补记录的缺点？
  - 什么情况下可以使用封装记录？
  - 封装记录的过程中有哪些需要注意的地方？
  - 了解封装记录是如何实现的。
- 封装集合（7.2）
  - 什么是错误的封装，它错误在什么地方？返回原始集合
  - 如何修改这样错误的封装？
  - 简要分析一下如何封装集合（参考封装记录）



# 9.重新组织数据
**重新组织数据章节分析**
- 变量类型、变量名、变量功能、变量访问性质
- 变量类型角度：值类型与引用类型的不同特点
- 变量名角度：要符合变量的功能，能够完全准确地描述变量
- 变量访问性质：封装，辅助前几点。

- 9.1 拆分变量
  - 普通参数
  - 输入参数（查询函数与修改函数分离）
- 9.2 字段改名
  - 封装作为一种手段辅助
- 9.3 以查询取代派生变量
  - 函数风格、对象风格
- 9.4 用值对象替代引用对象
- 9.5 使用引用对象替代值对象

> 简化条件逻辑、重构API都有一个思路，是合并、简化。前者体现在合并条件逻辑，后者体现在函数参数化。
# 10.简化条件逻辑
**简化条件逻辑章节分析**
- 条件逻辑分类：简单条件逻辑、嵌套条件表达式、switch形式的条件逻辑、复杂条件逻辑（简化为前三者处理）
- 使用条件逻辑提供信息：卫语句（卡诺图类型）、断言
- 多个相同的条件逻辑、更多的功能、特征：多态
- 其他技巧：将条件反转。

- 10.1 分解条件表达式
  - 对每一个分支采取 “提炼函数”。 非常简单，没什么特别的。
- 10.2 合并条件表达式
  - 检查条件不同，行为一致。
  - 检查条件是否应该独立？如果不独立，使用合并条件表达式，否则分别独立开，可以考虑使用提炼函数做额外处理。
- 10.3 以卫语句取代`嵌套条件表达式`
  - 卫语句：如果某个条件极其罕见，就应该单独检查该条件，并在条件为真时，立刻从函数返回，这样的单独检查常常被称作“卫语句”。
  - 处理方式：从最外层条件开始，处理为卫语句。全部处理完后可以考虑“合并条件表达式”
  - > 一个技巧：通过条件反转来使用卫语句。
- 10.4 以多态取代条件表达式 Replace Condinal with Polymorphism
  > 个人角度：多态意味着抽象、意味着使用接口（抽象类）实现这个抽象。  
  > 需要使用多态的场景：复杂的条件语句（多个条件语句，都需要使用这样的分发机制）
  - 书中实例，多个行为随着鸟的类型进行变化。（即存在多个条件分发行为均依赖同一条件逻辑）
  - 变体逻辑：我想表达某个对象与另一个对象大体相似，但又有一些不同之处。
    - 基本类的构成。
    - 变体逻辑的提取。
    - 为变体逻辑拆分的函数-->改到足够干净。
- 10.5 引入特例
  - 使用特例对象（可能是将某个基本类改成对象）
  - 不变时，使用不可变对象。
  - 使用增强（对记录，即字典），增强为一个类，添加部分功能，替代特例行为。
- 10.6 引入断言
  - 断言可以引入信息：假定。

# 11.重构API
**重构API章节分析**
- 函数的结构：返回值、函数名、参数列表
- 函数的功能：do something
- 函数的类型：类方法、普通方法、类方法中的特殊方法（构造方法，局限性-->工厂函数替代构造方法）
  - 维度1：函数的行为
    - 查询函数和修改函数分离。函数的返回值存在与否，带来的特殊信息。
  - 维度2：函数的基本用途
    - 函数使用参数取代多个函数（参数最好是：字面值）-->函数参数化。
  - 维度3：函数的参数和性质
    - 带来复杂度的参数：标记参数
    - 不透明的参数：对象参数
    - 因为参数的复杂性，带来了函数的额外职责，添加了依赖，但可以减少了参数：查询。（查询和参数的互相切换）
  - 维度4：与类相关
    - 类的不变性：设值函数移除
    - 利用类添加特性：以命令取代函数，不需要这么复杂的类来替代函数，则使用函数取代命令。
  - 维度5：构造函数
    - 使用工厂函数替代构造函数

- 11.1 将查询函数与修改函数分离(Seperate Query from Modifier)
- 11.2 函数参数化(Parameterize Function)
- 11.3 移除标记参数(Remove Flag Argument)
- 11.4 保持对象完整(Preserve Whole Object)
- 11.5 以查询取代参数(Replace Parameter with Query)
- 11.6 以参数取代查询(Replace Query with Parameter)
  - 引用透明性(referencial transparency)
- 11.7 移除设值函数(Remove Setting Method)
  - 尽可能保证对象不可变
- 11.8 以工厂函数取代构造函数(Replace Constructor with Factory Function)
  > 1.工厂方法函数允许动态生成对象。  
  > 2.抽象工厂允许指定工厂，动态生成对象。
  - 工厂函数有非常高的价值。
- 11.9 以命令取代函数(Replace Function with Command)
- 11.10 以函数取代命令(Replace Command with Function)


# 12.处理继承关系

- 12.3 构造函数上移
  - 构造函数比普通函数有着更多的限制，针对构造函数，需要额外做处理。
  - 构造函数的工作原理基本情况：父类初始化共用的数据，再由各个子类完成额外的工作。
  - 特殊情况：需要将公用的行为，初始化提升至超类。
    - 例子：isPrivileged依赖于子类数据，又`需要子类初始化`，每一个子类都需要这么一个公共行为。
    - 添加finishConstruction作为公共行为。子类最后调用。

- 12.10 以委托取代子类（Replace Subclass with Delegate）
  - 类似于桥接模式（书上写着用策略模式和状态模式理解应该出错了）
  - 1.策略模式：一个类，接收不同参数，使用不同策略。
  - 2.状态模式：一个状态类，固定行为，改变上下文（依据上下文现有的参数），
  - 3.桥接模式：使类在两个维度分别变化。`以委托取代子类 就是 桥接模式`