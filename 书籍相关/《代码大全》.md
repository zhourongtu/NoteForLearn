参考资料：

《代码大全》

# 创建高质量的代码
## 第6章、可以工作的类
类、ADT的定义，类和ADT的区别 参考 基础概念辨析.md
- 1.认识ADT与类，以下阐述ADT相关知识点
  - 好处
    - 隐藏实现细节
    - 改动不影响整个程序
    - 让接口提供更多信息
    - 容易提高程序性能
    - 让程序的正确性显而易见
    - 让程序更具自我说明性
    - 无需在程序内到处传递数据
    - 可以像在现实世界中那样操作实体，而不用在底层实现上操作它
  - 例子：字体定义
  - 指导建议
    - 把常见的数据类型创建为ADT并使用这些ADT
    - 把像文件这样的常用对象当成ADT
    - 简单的事务也可以当作ADT
    - 不要让ADT依赖于存储介质
  - 在非面向对象环境中使用ADT处理多份数据实例的三个方式
    - 使用ADT服务子程序明确指定实例（如fontId）
    - 明确地向ADT服务子程序提供所要用到的数据。
    - 使用隐含实例。
      - 比如：设计一个新的服务子程序，通过它让某个特定的字体实例成为当前实例。
      > 不推荐，系统范围内对状态的依赖，意味着需要用到字体操作时，所有代码需要跟踪当前的字体实例。
- 2.创建高质量的类
  > 第一步，也是最重要的一步，创建一个好的接口。  
  - 创建良好的接口
    - 隐含两个概念
      - 1.创建一个`可以通过接口来展现的合理的抽象`。
      - 2.并 确保`细节`被`隐藏`在抽象的背后。
    > 类的接口为实现细节提供了一种抽象，`这种抽象应该具有一致性`  (推导结论，由表现推导)。  
    > 表现为：能够提供一组明显相关的子程序。
    - 例子
      - 一个良好的抽象：雇员，一组获得雇员信息的方法。
      - 一个不良的抽象：程序，提供了各种各样的功能。
    - 指导意见
      - 类的接口应该展现一致的抽象层次
        - 一个类中 雇员抽象 + 列表抽象的例子
      - **一定要理解类所实现的抽象是什么**
        - 电子表格（150个子程序）、栅格控件（15个）
        - 使用包裹类（wrap class）隐藏“把电子表格控件用作栅格控件”这一事实。
      - 提供成对的服务
      - 把不相关的信息转移到其他类中
      - 尽可能让接口可编程，而不是表达语义（**这部分内容作为接口，放在基础概念辨析中**）
      - 谨防在修改时破坏接口的抽象
      - 不要添加与接口抽象不一致的公共成员
      - 同时考虑抽象性和内聚性（两个概念非常紧密）
        - 一个呈现出良好的抽象的类接口通常有很高的内聚性。
        - 而具有很高的内聚性的类往往也会成为很好的抽象（尽管这种关系不如前者那么强）。
     > 关注类的接口所表现出来的抽象，比关注类的内聚性更有助于深入地理解类的设计。如果觉得某个类的内聚性非常弱，也不知道怎么改，可以问问自己这个类是否表现出一致的抽象。
  - 良好的封装  
    > 封装和抽象的概念辨析，参考基础概念辨析.md。
    - 尽可能地限制类和成员的可访问性
      - 考虑`“采用哪种方式能最好地保护接口抽象的完整性”`。
    - 不要公开暴露成员数据
    - 避免把私用的实现细节放入类的接口中
      - 做到真正的封装后，程序员们应该看不到任何实现细节。（无论是字面上还是寓意上）
      - C++却从语言结构上要求程序员在类的接口中透露实现细节（在类的头文件可以看到private的变量，这鼓励程序员查阅实现细节）
      - Effective C++ 建议把类的接口和类的实现隔离开，并在类的声明中包含一个指针，让该指针指向类的实现，但不能包含其他任何细节。
    - 不要对使用者做出任何假设——除非接口有明确说明（参考接口的可编程部分、语义部分概念辨析）
    - 避免使用友元类(friend class)——破坏封装。
      - 正确的方式，如State模式中使用友元类有助于管理复杂度。
    - 不因为一个子程序里仅使用公用子程序，就把它归入公开接口。
    - 让阅读代码比编写代码更方便。
    - 要格外警惕从语义上破坏封装性。
      - 语法：设为private
      - 语义：某个函数被另外一个函数隐含调用。
    - 留意过于紧密的耦合关系
- 3.有关设计和实现的问题
  > 主要讨论 包含、继承、成员函数 和 数据成员 、类之间的耦合性、构造函数、值对象、引用对象。
  - 包含关系(has-a)
    - 使用包含实现has-a关系
    - 万不得已情况下使用private继承
      - 原因：让外层的包含类能够访问被包含类的protected成员函数与数据成员。
      - 其实也可以用其他方式解决。
    - 警惕7个以上的成员函数。（复杂考虑7-2，简单考虑7+2）
  - 继承关系（is-a）
    - public继承实现is-a关系
    - 要么使用继承并进行详细说明，否则不使用。
    - 遵循里氏替换原则（面向对象基本原则）
    - 确保继承只需要继承的那一部分。
  - 成员函数与数据成员
  - 构造函数
    - 如果可能，应该在所有的构造函数中初始化所有的数据成员。
      > 《重构》11.7，移除设值函数————清晰的表达对象不可变的意图。
    - 用私有构造函数来强制实现单件属性(single property)
    - 优先使用深层拷贝，除非论证可行，才使用浅层拷贝。
- 4.认识创建类的原因

## 第7章、高质量的子程序


## 第8章、防御式编程
防御式编程的主要思想：子程序应该不因传入的数据错误而被破坏，哪怕式由其他子程序产生的错误数据。
> 核心想法：承认程序都会有问题，都需要被修改，聪明的程序员应该根据这一点编写程序。  

> 如何面对严酷的非法数据的世界、在遇到“绝对不会发生”的事件以及其他程序员犯下的错误时，保护好你自己。  

> 应该自始自终考虑各种各样的错误处理机制，不应该由语言限制了自己。

**8.1 保护程序免遭非法输入数据破坏**
三种方法：
- 检查所有来源于外部的数据的值
- 检查子程序的所有输入参数的值
- 决定如何处理错误的输入数据
**8.2 断言**
1. 断言是用来做什么的？
   - 程序运行自检的代码
   - 断言是一种假定
2. 断言在什么时候使用？
   - 用错误处理代码来处理预期会发生的情况，用断言来处理绝不应该发生的状况
   - 执行的代码不要和断言一起使用（容易被排除在外，不编译）
3. 断言和错误处理技术是否可以同时使用？可以。
**8.3 错误处理技术**
**8.4 异常**
**8.5 隔离程序**
**8.6 辅助调试的代码**
**8.7 确定产品中保留多少防御式代码**
**8.8 对防御式编程采取防御的姿态**