参考资料：

《代码大全》

# 打好基础

## 第1章、欢迎进入软件构件的世界
**构建的基本含义**
- 基本含义：建设的过程。
- 通常使用的含义：建设的过程中`动手的那一部分`。

**需要回答的问题**
- 1.什么是软件构建？（1.1标题）
  - 构建活动主要关注`编码与调试`，还有一些其他活动（详细设计、单元测试、集成测试等）
  > 使用`编程`来认识软件构建。（创造力、判断力）
- 2.构建的具体任务是什么？
  > **确认基础工作、设计如何测试、设计、编写、测试、评审、润饰、集成、优化**。
  - 确认构建活动的基础工作已经完成，可以进行构建活动。
  - 确定如何测试构建的代码。
  - 设计如何编写类、子程序
  - 创建并命名变量和具名常量
  - 选择控制结构（control structure），组织语句块
  - 对代码进行单元测试、集成测试，排除其中的错误
  - 评审
  - 润饰代码，进行代码的格式化与注释
  - 将单独开发的多个软件集为一体。
  - 调整代码（tuning code），令他更快，更节省资源。
- 3.基于什么，判断构建活动非常重要？
  > 主要，就是构建活动的唯一核心原因。
  - 构建活动是软件开发的主要组成部分（数据支撑 30% ~ 80%）
  - 构建活动是软件开发的核心活动（前：需求分析、架构设计。后：测试）
  - 对主要部分进行优化，提高效率。
  - 构建活动的产物————源代码，是对软件的唯一精确描述。（最新）
  - 构建活动是唯一确保会被完成的工作。（其他都是影响）
  - 构建活动对软件的质量有着实质性的影响。

## 第2章、用隐喻来更充分地理解软件开发
> 隐喻可以帮助我们清楚地理解软件开发的过程。
- 1.隐喻的重要性（2.1内容）
  - 使用隐喻的基本方式：建模。
    > 通过把不太理解的东西与较为理解的、且十分相似的东西作比较，那么就能够获取对不太理解的东西的深刻理解。
- 2.隐喻与算法的区别
  - 算法是可预测的、确定性的、不易变化的
    > 回顾算法定义：（来自算法导论）  
    > **算法**：定义良好的计算过程，通过一系列计算步骤用来将输入数据转化成输出结果。  
  - 隐喻更像是一种启发式的方法。区别在于————间接程度。
- 3.如何使用隐喻？
  - 理解2
  - 用来提高对编程问题和编程过程的洞察力
  - 用来帮助思考编程过程的活动
  - 想象出更好的做事情的方法
- 4.常见的软件隐喻
  - 写作：原创性。软件需要重用
  - 耕作，培植系统：每次做一点。（增量，但是软件不完全是增量）
  - 系统生长：增量的(incremental)、迭代的(iterative)、自适应的(adaptive)、演进的(evolutionary)。
    - 骨架、替换，依次增加。
  - 软件`建造`
    - 1.建造推倒重来的成本高。
    - 2.适当的多层次的规划对建造建筑物和构建软件都有好处。
  - 应用软件技术，智慧工具箱。
    - 把所有的技术、方法留在脑海里，在合适的时候拿来使用。
  > 隐喻是一种启发式方法，而不是算法，它只是一种帮助理解的工具。





## 第3章、三思而后行：前期准备
- 准备什么？准备有什么好处？
- 强调质量？项目的前中后期，不同的`高质量的实践方法`
- 准备工作的中心目标就是降低风险。
  > 认真地进行适当的准备活动，项目运作将会不错。
- 准备活动不周全的原因分析

## 4.关键的“构建”决策

## 1-4章总结



# 创建高质量的代码
## 第6章、可以工作的类
类、ADT的定义，类和ADT的区别 参考 基础概念辨析.md
- 1.认识ADT与类，以下阐述ADT相关知识点
  - 好处
    - 隐藏实现细节
    - 改动不影响整个程序
    - 让接口提供更多信息
    - 容易提高程序性能
    - 让程序的正确性显而易见
    - 让程序更具自我说明性
    - 无需在程序内到处传递数据
    - 可以像在现实世界中那样操作实体，而不用在底层实现上操作它
  - 例子：字体定义
  - 指导建议
    - 把常见的数据类型创建为ADT并使用这些ADT
    - 把像文件这样的常用对象当成ADT
    - 简单的事务也可以当作ADT
    - 不要让ADT依赖于存储介质
  - 在非面向对象环境中使用ADT处理多份数据实例的三个方式
    - 使用ADT服务子程序明确指定实例（如fontId）
    - 明确地向ADT服务子程序提供所要用到的数据。
    - 使用隐含实例。
      - 比如：设计一个新的服务子程序，通过它让某个特定的字体实例成为当前实例。
      > 不推荐，系统范围内对状态的依赖，意味着需要用到字体操作时，所有代码需要跟踪当前的字体实例。
- 2.创建高质量的类
  > 第一步，也是最重要的一步，创建一个好的接口。  
  - 创建良好的接口
    - 隐含两个概念
      - 1.创建一个`可以通过接口来展现的合理的抽象`。
      - 2.并 确保`细节`被`隐藏`在抽象的背后。
    > 类的接口为实现细节提供了一种抽象，`这种抽象应该具有一致性`  (推导结论，由表现推导)。  
    > 表现为：能够提供一组明显相关的子程序。
    - 例子
      - 一个良好的抽象：雇员，一组获得雇员信息的方法。
      - 一个不良的抽象：程序，提供了各种各样的功能。
    - 指导意见
      - 类的接口应该展现一致的抽象层次
        - 一个类中 雇员抽象 + 列表抽象的例子
      - **一定要理解类所实现的抽象是什么**
        - 电子表格（150个子程序）、栅格控件（15个）
        - 使用包裹类（wrap class）隐藏“把电子表格控件用作栅格控件”这一事实。
      - 提供成对的服务
      - 把不相关的信息转移到其他类中
      - 尽可能让接口可编程，而不是表达语义（**这部分内容作为接口，放在基础概念辨析中**）
      - 谨防在修改时破坏接口的抽象
      - 不要添加与接口抽象不一致的公共成员
      - 同时考虑抽象性和内聚性（两个概念非常紧密）
        - 一个呈现出良好的抽象的类接口通常有很高的内聚性。
        - 而具有很高的内聚性的类往往也会成为很好的抽象（尽管这种关系不如前者那么强）。
     > 关注类的接口所表现出来的抽象，比关注类的内聚性更有助于深入地理解类的设计。如果觉得某个类的内聚性非常弱，也不知道怎么改，可以问问自己这个类是否表现出一致的抽象。
  - 良好的封装  
    > 封装和抽象的概念辨析，参考基础概念辨析.md。
    - 尽可能地限制类和成员的可访问性
      - 考虑`“采用哪种方式能最好地保护接口抽象的完整性”`。
    - 不要公开暴露成员数据
    - 避免把私用的实现细节放入类的接口中
      - 做到真正的封装后，程序员们应该看不到任何实现细节。（无论是字面上还是寓意上）
      - C++却从语言结构上要求程序员在类的接口中透露实现细节（在类的头文件可以看到private的变量，这鼓励程序员查阅实现细节）
      - Effective C++ 建议把类的接口和类的实现隔离开，并在类的声明中包含一个指针，让该指针指向类的实现，但不能包含其他任何细节。
    - 不要对使用者做出任何假设——除非接口有明确说明（参考接口的可编程部分、语义部分概念辨析）
    - 避免使用友元类(friend class)——破坏封装。
      - 正确的方式，如State模式中使用友元类有助于管理复杂度。
    - 不因为一个子程序里仅使用公用子程序，就把它归入公开接口。
    - 让阅读代码比编写代码更方便。
    - 要格外警惕从语义上破坏封装性。
      - 语法：设为private
      - 语义：某个函数被另外一个函数隐含调用。
    - 留意过于紧密的耦合关系
- 3.有关设计和实现的问题
  > 主要讨论 包含、继承、成员函数 和 数据成员 、类之间的耦合性、构造函数、值对象、引用对象。
  - 包含关系(has-a)
    - 使用包含实现has-a关系
    - 万不得已情况下使用private继承
      - 原因：让外层的包含类能够访问被包含类的protected成员函数与数据成员。
      - 其实也可以用其他方式解决。
    - 警惕7个以上的成员函数。（复杂考虑7-2，简单考虑7+2）
  - 继承关系（is-a）
    - public继承实现is-a关系
    - 要么使用继承并进行详细说明，否则不使用。
    - 遵循里氏替换原则（面向对象基本原则）
    - 确保继承只需要继承的那一部分。
  - 成员函数与数据成员
  - 构造函数
    - 如果可能，应该在所有的构造函数中初始化所有的数据成员。
      > 《重构》11.7，移除设值函数————清晰的表达对象不可变的意图。
    - 用私有构造函数来强制实现单件属性(single property)
    - 优先使用深层拷贝，除非论证可行，才使用浅层拷贝。
- 4.认识创建类的原因

## 第7章、高质量的子程序


## 第8章、防御式编程
防御式编程的主要思想：子程序应该不因传入的数据错误而被破坏，哪怕式由其他子程序产生的错误数据。
> 核心想法：承认程序都会有问题，都需要被修改，聪明的程序员应该根据这一点编写程序。  

> 如何面对严酷的非法数据的世界、在遇到“绝对不会发生”的事件以及其他程序员犯下的错误时，保护好你自己。  

> 应该自始自终考虑各种各样的错误处理机制，不应该由语言限制了自己。

**8.1 保护程序免遭非法输入数据破坏**
三种方法：
- 检查所有来源于外部的数据的值
- 检查子程序的所有输入参数的值
- 决定如何处理错误的输入数据
**8.2 断言**
1. 断言是用来做什么的？
   - 程序运行自检的代码
   - 断言是一种假定
2. 断言在什么时候使用？
   - 用错误处理代码来处理预期会发生的情况，用断言来处理绝不应该发生的状况
   - 执行的代码不要和断言一起使用（容易被排除在外，不编译）
3. 断言和错误处理技术是否可以同时使用？可以。
**8.3 错误处理技术**
**8.4 异常**
**8.5 隔离程序**
**8.6 辅助调试的代码**
**8.7 确定产品中保留多少防御式代码**
**8.8 对防御式编程采取防御的姿态**