参考资料

《算法导论》
- 基础知识
  - 第1章、算法在计算中的应用
  - 第2章、算法入门

# 1.掌握算法的基本定义，定义问题、定义算法。
**算法**：定义良好的计算过程，通过一系列计算步骤用来将输入数据转化成输出结果。  
**算法的规格要求**：提供待执行的计算过程的精确描述。

## 1.1 排序问题的定义
输入：由n个数组成的序列<a_1, a_2, a_3, ..., a_n>
输出：对输入序列的一个重排<a'_1, a'_2, ..., a'_n>，使得a'1<=a'2<=a'3<=...<=a'n
- 正确的算法：一个算法对其每一个输入的实例都能输出正确结果并停止。
- 不正确的算法：not 正确的算法。错误率可以控制则也很有用。

## 1.2 掌握logn、n、nlogn、n^2、n^3、n!的时间复杂度的实际概念与计算方式。
- 时间复杂度的基本计算方式：积分计算
- 问题：对于下表中的每一个函数f(n)和时间t，求出可以在时间t内被求解出来的问题的最大规模n。
  > 对应code放在algo_1相关。

# 2.掌握伪代码描述算法，证明它能够正确地完成任务，能够对时间复杂度进行分析
**概念定义**
- 运行时间
- 输入规模：在待定输入时，程序所执行的步数。
> 计算运行时间的方式，可以通过分析代码每一行获得，对每一行代码的运行时间给予常量c，执行次数t，相乘累加。
$$
time = \Sigma c_it_i
$$
> 在分析算法时，需要掌握最坏时间、最佳时间、平均时间复杂度。

## 2.1 掌握循环不变式(loop invariant)的定义，并利用它做证明。
- 三个性质：初始化、保持、终止。（数学归纳法？）
  - 初始化：它在循环的第一轮迭代开始前，应该是正确的。
  - 保持：如果在循环的某一次迭代开始之前它是正确的，那么在下一次迭代开始前，它也应该保持正确。
  - 终止：当循环结束时，不变式给我们一个有用的性质，它有助于算法是正确的。
- 与数学归纳法的不同
  - 数学归纳法无穷使用
  - 这里循环结束，终止“归纳”

1. 插入排序
```
for j <- 2 to Length(A)
  do key <- A[j]
  Insert key into the sorted sequence A[1...j-1]
  i <- j-1
  while i>0 and A[i] > key:
    do A[i+1] <- A[i]
    i < i+1
  A[i+1] <= key

循环不变式：
1.初始化：每次循环开始前A[1 to j-1]有序
2.保持：本次循环结束后，下一次迭代开始前，A[1 to j]有序
3.终止：j = Length(A) + 1时，终止。保持A[1 to Length(A)]有序。
```

2. 选择排序
```
for i <- 2 to Length(A)
  do key <- A[i-1]
  Find maximum or minimum num in sequence A[i-1 to Length(A)]
  num_index <- i # initialize max_num as i
  for j <- i to Length(A)
    if num < A[j]:
      num = A[j]
      num_index = j
  exchange A[i-1] with A[num_index]
```

循环不变式：
1.初始化：每次循环开始前A[1 to i-1]有序
2.保持：本次循环结束后，下一次迭代开始前A[1 to i]有序
3.终止：i = Length(A) + 1时，终止。保持A[1 to Length(A)]有序

## 2.2 分析线性查找问题
最坏情况：n次
最好情况：1次
平均情况：n/2次
最坏情况和最好情况表示方式：O(n)

## 2.3 了解最基本的算法设计：增量方法、**分治法（重点掌握）**，掌握其证明、时间复杂度等概念。
1. 插入排序说明：增量方法。
2. 分治法
- 算法在结构上是递归的：为了解决一个给定的问题，算法要一次或多次递归调用其自身来解决相关的子问题。
- 分治策略：将原问题划分成n个规模较小而结构与原问题相似的子问题；递归地解决这些子问题，然后再合并其结果就可以得到原问题的解。
- 步骤：
  - 分解(Divide)：将问题分解成一系列子问题。
  - 解决(Conquer)：递归地解各子问题。若子问题足够小，则直接求解。
  - 合并(Combine): 将子问题的结果合并成原问题的解。
3. 合并排序
  分解：将n个元素分解成各含n/2个元素的子序列；
  解决：用合并排序法对两个子序列递归地进行排序；
  合并：合并两个已排序的子序列以得到排序结果。
```
MERGE(A, p, q, r)
n1 <- q-p+1
n2 <- r-q
Arrays_L[1, ..., n1+1], Arrays_R[1, ..., n2+1]
for i <- 1 to n1
  do L[i] <- A[p+i-1]
for j <- 1 to n2
  do R[j] <- A[q+j]
L[n1+1] = ~
R[n1+1] = ~
i <- 1
j <- 1
for k<- p to r:
  do if L[i] <= R[j]
    then A[k] <- L[i]
      i <- i+1
    else A[k] <- R[j]
      j <- j+1

MERGE_SORT(A, p, r)
if p < r
  then q <- [(p+r)/2]
    MERGE_SORT(A, p, q)
    MERGE_SORT(A, q+1, r)
    MEREG(A, p, q, r)
```
- 算法证明（MERGE，循环不变式）
  - 初始化：循环开始前，k=p，子数组A[p, ... k-1]为空。
  - 保持：L[i]与R[j]为未被复制回A的最小元素，复制以后，A[p...k]包含k-p+1个最小元素。
  - 终止：终止时，k=r+1。此时有子数组A[p, ... r]包含了L、R共r-p+1个最小元素并排好序。L和R包含的元素中，除了哨兵，均已复制回去。
- MERGE时间复杂度证明
  - 复制次数：复制次数O(n1+n2)，循环次数n次。
- MERGE_SORT时间复杂度递归方程
$$
T(n)=\begin{cases}
    -\Theta(1),\quad n=1\\
    -2T(n/2) + \Theta(n), \quad n\gt c\\
\end{cases}
$$
$$
T(n) = \Theta(nlgn)
$$

**分治法分析**
- 当一个算法含有对自身的递归调用时，运行时间可以用一个递归方程（递归式）来表示。该方程通过描述子问题与原问题的关系，来给出总的运行时间，利用数学解递归式，并给出算法性能的界。
- 通过递归树可以计算算法的代价（需要掌握）


$$
T(n)=\begin{cases}
    \Theta(1),\quad n\leq c\\
    aT(n/b) + D(n) + C, \quad n\gt c\\
\end{cases}
$$

## 作业题
- 插入排序的递归式
$$
T(n) = T(n-1) + n
$$

- 二分查找算法
  - 时间复杂度说明O(lgn)
$$
T(n) = \begin{cases}
1, \quad n=1\\
2T(n/2) + 1, \quad n!=1\\
\end{cases}
$$
  - 演化
    - 通过二分查找查找出所有的值(不止一个)
      - 进一步再做优化？

- 选择排序的二分查找优化
  - 无法解决移动的问题。lgn查找+n移动。
  - if 链表: 可以解决对应问题，lgn查找+1移动。
    - 时间复杂度：
    $$\Sigma_1^n logn = \Theta(nlogn)$$

- 有趣的时间复杂度说明
  $$\Sigma_1^n nlogn = \Theta(n^2logn)$$

## 思考题
1. 合并排序的小数组使用插入排序优化
    - 证明n/k个子列表可以用插入排序在O(nk)时间完成排序
      - n/k * O(k^2) -->  O(nk)
    - 证明子列表在O(nlg(n/k))最坏时间完成合并。
      - 每一层合并n，少合并lgk层，n(lgn - lgk) = n(lg(n/k))
    - 最终表示：nlogn
    - 实践中k的选取？归并排序和插入排序，在k的个数计算咯？

2. 冒泡排序算法
3. 霍纳规则的正确性，Horner'Rule 霍纳规则，多项式计算。
    - 时间复杂度O(n)
4. 逆序对（可以使用归并排序计算逆序数）

