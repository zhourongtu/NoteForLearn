**DTO**: 数据传输对象  
**marshal**: 直译为“编排”，在计算机中特指将数据按某种描述格式编排出来，通常来说一般是从非文本格式到文本格式的数据转化。unmarshal自然是指marshal的逆过程。
**TDD(Test-Driven Development)**：测试驱动开发  
**DefensiveProgramming**：防御式编程  
**函数式编程**
  - 闭包（闭包起函数的作用，并可以像操作对象一样操作函数）
    - 支持函数称为第一类对象，称为“闭包”或“仿函数对象”
  - 高阶函数
    - 可以由另一个函数作为输入参数，允许返回一个函数作为输出参数。
  - 惰性计算
    - 表达式不再绑定到变量时进行计算，而是在求值程序需要产生表达式的值时，进行计算。
    - 允许编写生成无穷输出的函数（不会计算多于程序的其余部分所需要的值）
**ADT(Abstract Data Type, 抽象数据类型) 与 类(class)** 
  - ADT：一些数据 和 对这些数据进行操作的集合
  - 类：一组 `数据` 和 `子程序` 构成的`集合`。
    - 这些 数据 和 子程序 共同拥有一组 **内聚的、明确定义的职责**。
    - 其他定义：一组子程序构成的集合，一组子程序提供一组内聚的服务，哪怕其中未涉及共用的数据。
  - ADT与类的区别
    - ADT是类的基础
    - 类涉及继承与多态这两个额外概念
    - 可以认为 `类 = ADT + 继承与多态`

**Interface(接口)**：每个接口由一个可编程(programmatic)的部分和一个语义(semantic)部分组成。
  > 参考：《代码大全》第6章 6.2的指导意见
  - 可编程部分：接口中的数据类型和其他属性构成（编译器能强制性地要求它们在编译时检查错误）。
  - 语义部分：“本接口将怎样被使用”的假定，这无法在通过编译器来强制实施。
    - 例子：“RoutineA必须在RoutineB之前调用”
    - 语义接口应该通过注释说明，但尽可能不依赖。
    - 一个接口中无法通过编译器强制实施的部分，就是一个可能误用的部分。
    - 想办法将语义接口转换为编程接口的元素，比如Assert等技术。
  - 良好的接口
    - 隐含两个概念
      - 1.创建一个`可以通过接口来展现的合理的抽象`。
      - 2.并 确保`细节`被`隐藏`在抽象的背后。
    > 类的接口为实现细节提供了一种抽象，`这种抽象应该具有一致性`  (推导结论，由表现推导)。  
    > 表现为：能够提供一组明显相关的子程序。

**封装**：强制阻止你看到细节
  > 参考：《代码大全》 第6章 标题：良好的封装

**封装与抽象的关系**
- 抽象通过提供一个可以让你忽略细节的模型来管理复杂度。
- 封装则强制阻止你看到细节——即便你想那么做。
  > 两个概念相关的原因：因为没有封装，抽象往往很容易被打破。往往两者皆有，或者两者皆失，没有第三种可能。

**耦合(coupling)**：是指两个类之间关联的紧密程度。
> 通常这种关系越松(loose)越好。

**耦合性与抽象和封装性的联系**
- 非常密切.
- 紧密的耦合性总是发生在抽象不严谨或封装性遭到破坏的时候
- 例子
  - 一个类提供了一套不完整的服务,其他的子程序可能要直接读写类的内部数据,这样一来就把类拆开了,从黑盒子变成了玻璃盒子.

## 面向对象基本原则
**1. 单一职责原则（Single Responsibility Principle）**
- 每一个类应该专注于做一件事情。

**2. 里氏替换原则（Liskov Substitution Principle）**
- 超类存在的地方，子类是可以替换的。
- **接口级别的抽象（invalid s）**
> 《代码大全》：除非派生类，真的“是一个”非常特殊的基类，否则不应该从基类继承。“派生类必须能够通过基类的接口而被使用，而使用者无需了解两者之间的差异。”

**3. 依赖倒置原则（Dependence Inversion Principle）**
- 实现尽量依赖抽象，不依赖具体实现。
- 经典实现：使用接口，依赖于抽象。

**4. 接口隔离原则（Interface Segregation Principle）**
- 应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口。
- 评价：尽可能利用接口隔离依赖目标，完成该目标同时可实现DIP原则。

**5. 迪米特法则（Law Of Demeter）**
- 又叫最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用。
- 评：高内聚，低耦合。

**6. 开闭原则（Open Close Principle）**
- 面向扩展开放，面向修改关闭。
- 经典实现：子类化。

**7. 组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）**
- 尽量使用合成/聚合达到复用，尽量少用继承。原则： 一个类中有另一个类的对象。