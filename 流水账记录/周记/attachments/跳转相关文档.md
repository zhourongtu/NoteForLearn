# 认识跳转
- BaseCCSPanel
  - 变量
    - ui_jump_chain
    - is_during_clean_jump_chain
  - 函数
    - check_self_in_jump_chain
    - add_myself_jump_chain
    - add_jump_chain

# 跳转
- 跳转信息
  - target_panel_name
  - scene_type --> target_panel_scene_type
- 跳转后，对target_panel做的操作所需的信息
  - func_name
  - func_operate_type
  - func_args
- 跳转后，对target_panel操作
  - func(xxx)
- 跳转情况分析
  - 当前的面板与跳转的面板处于同一个 --> do_for_target
    - do_for_target的调用时间-->
  - 不是同一个
    - 检查当前状态
      - Globals.fashion_scene_mgr --> 是否处于带场景的UI中
      - 目标UI是否带场景
    - 如果当前处于带场景的UI中，且目标带场景
      - 注意：带场景的UI中不意味着当前面板属于带场景的面板-->有可能是打开了某个界面（无场景界面）


# 跳转功能文档
**摘要**：本文讨论了跳转功能的基本定义，程序实现跳转功能的主要挑战，以及在蛋仔派对项目中的主要跳转需求与实现方案，在文章的最后提出了一些注意点和优化方向。


## 1. 简要的对跳转功能的看法与说明
- 基本定义：跳转功能的基本目的是游戏中使玩家能够**快速**访问并浏览不同的内容和功能。
- 从实现的角度来看待跳转功能，通常来说会碰到以下的一些困难
  - 页面生命周期的管理：当玩家从一个页面跳转到另一个页面时，需要考虑如何管理页面的生命周期。
    1. 当前的页面如何处理？销毁、隐藏、支持恢复（隐藏以支持恢复，保存页面状态以支持恢复）
  - 数据传递
    1. 初始化被跳转的界面。
    2. 被跳转的界面提供数据以修改原界面。
    3. 其他目的。
    4. 退出被跳转的界面时，如何恢复旧的界面。
  - 支持多对象的跳转处理一致性
  - 性能问题
    - 不断地跳转，导致隐藏了太多的界面，占用了大量的内存。
  - 成环问题
    - 经过几轮跳转后，结果又能够跳转到某一个界面的起点。


## 2. 蛋仔派对中跳转功能的需求分析
- 1.弹图需求
  - 弹图点击前往，可以跳转至对应目标，当关闭目标后，弹图将恢复，并进入下一张弹图。
- 2.任务跳转需求
  - 任务可以点击前往，引导玩家到完成任务的地方。
- 3.类商城跳转需求
  - 商城能够根据商品需要，跳转至获取商品的地方，并支持返回。
- 4.多轮跳转
- 5.直接跳转需求
  - 不同界面无需配置跳转，只是为了单纯地前往某个目标。
- 6.跳转存在的数据传递问题
- 7.精灵跳转
- 8.分享跳转


## 3. 游戏内通用的跳转功能实现与说明
> 该内容讨论了游戏内实现的游戏内跳转功能的基本介绍

### 1类跳转功能（商城类跳转，跳转后能返回）
- 参见代码： AdJumpHelper

### 2类跳转功能（任务的点击跳转）
- AdJumpHelper 中 task_jump_to_target（对1类做了封装、并增加了清空功能）

### 3类跳转功能（直接跳转）
- JumpToPanelHelper
  - 目前该功能，经迭代后，不再由任务使用，程序可以利用这个实现，实现定向跳转。

## 4. 跳转功能的原理与实现细节
### 跳转功能的基础
- 页面跳转时的生命周期管理
  - 1.跳转后，上一个界面如何获取
    - BaseCCSPanel 中，以 ui_jump_chain 存储了当前的跳转栈
  - 2.返回时，如何恢复旧的界面
    - 关闭当前界面，显示旧界面

### 通用跳转实现的封装
- 1.跳转实现的结构
  - 参见 ShopPanel
  - 面板A 实现跳转、返回的逻辑
    - 跳转逻辑 (set_jump_ui)
      - a) 对自己的面板做处理
        - 1.隐藏自身面板
        - 2.将自己的面板加入到"栈"中
      - b) 跳转至目标面板
    - 返回逻辑 (on_before_destroy时，调用 check_ui_pop_chain)
      - a) 重新设计关闭面板
        - 判断是否属于跳转的面板，如果是，则弹出前一个面板
    - 被返回逻辑 (set_jump_ui)
      - a) 展示自身面板
      - b) 恢复面板状态
- 2.生命周期的划分
  - 参见 AdJumpHelper文件
  - AdJumpHelper 跳转行为的实现为
    - 1.确定跳转目标，分析实现跳转的条件
    - 2.利用 “1.跳转实现的结构” 与 “跳转带场景UI” 与 “打开UI” 等方式，构建跳转行为。
    - 3.在保证跳转结束后，对面板做处理
  - 跳转时机
    - 1.立即跳转，此时在同一帧打开面板、切换场景。
    - 2.延迟跳转
      - 主要原因：需要关闭旧界面，才能跳转
      - 关掉旧界面的阻碍：
        - 1.部分UI场景的退出与帧命令绑定
        - 2.部分UI的关闭需要播放动画。
        - 3.多级跳转条件下，可能出现混合限制。
  - 面板的生命周期（利用面板的生命周期，作为跳转时机的参考）
    - 打开面板
    - 关闭面板
    - 从蛋仔岛进入场景
    - 从蛋仔岛退出场景
  - 跳转的生命周期（整个跳转的生命周期，用来判断什么时候做什么样的事情）
    - 确定跳转当前的condition
      - 跳转功能是否依赖于全权处理？
    - 确定跳转的限制，并处理
    - 确定跳转的时机
    - 确定跳转后进行的设置
    - 参见 AdJumpHelper文件中的 AdJumpHelper类
      - 抽象：利用面板的生命周期，延迟调用某函数。
  - 具体细节代码
    - 划分清楚后，利用 AdJumpHelper，对合适的目标做设置，就可以保证上述每一个环节的稳定性。
- 3.部分编写细节说明
  - 弹窗相关
    - 不是所有的面板都会尝试 check_ui_pop_chain，为弹窗，特地设置了 set_close_cb 去调用，经测试无问题，可建议修改。
    - 弹窗将自己加入了跳转链，以实现回到弹窗的功能（同时又加入自身，直到弹窗销毁为止）
      - 旧的实现非常生硬，后续改成了利用 “1.跳转实现的结构”。
      - 这一功能的体现将在AdManager、AdPanel与AdJumpHelper中得到体现。
      - 注：这块代码的明显程度不够，最好能够做一定调整，让这个信息更加明确（笔者加了注释，但是**由于该功能的实现跨了多文件，所以维护的敏感度不够强**）


## 5. 当前跳转功能实现存在的问题
- 1.跳转实现的结构问题
  - 抽象层未良好地划分
    - a) BaseCCSPanel提供的API中
      - add_jump_chain 承担了两个职责
        - 加入自己到跳转链中
        - 打开目标面板
  - 代码相似，却分布在不同的文件中，有较多的冗余
  - 没有对“无法直接打开的UI”做处理，而是分布在特殊处理中。
- 2.代码冗余问题
  - a) 跳转代码的相似性
  - b) 通用界面在支持跳转功能时，采用的是“回调地狱”的方式，导致跳转代码的删除增大了难度。
  - c) 部分界面为了“保底”，做了一些可能永远调不到的代码，增加了代码的复杂度。


## 6. 迭代参考
- 1.在前一次的跳转迭代中，将 弹窗、任务、商城的跳转统一了，并提出了 AdJumpHelper的生命
  - 如果能将原来的set_jump_ui再统一过来，就比较完善了。
- 2.如果能够将jump_to_recharge，利用 jump_to_target 进一步拓展。做通用化，可以避免大量的 jump_to_recharge的api编写。
  - 笔者先前做了多次尝试
    - 比如RechargePanelComp，希望能够避免编写重复的代码，但是感觉可用性不高。
    - 比如将resume_panel等划分多个函数，以达到更详细的，支持更通用的跳转，但实用性也不太高，并且维护成本有所提升，就放弃了。
- 3.jump_to_target能够获取很多信息，可以考虑再添加一些信息来解决迭代中可能碰到的问题。
- 4.对通用面板的回调行为，如果能够改为一个 config（包含起点、终点等的注册），可能可以解决回调地狱的问题。


## 一些问题
- 1.一些面板的定向跳转，需要自己维护数据传递。
  - 笔者认为，自己维护该数据是比较合理的，因为毕竟是固定的跳转路线，而不是配置型的方式，后者多变，并且跳转路径不唯一。
- 2.跳转目前采用的是隐藏面板，不可避免地带来内存增长
  - 笔者认为，面板的终极抽象，是备忘录，即一堆数据就能够恢复整个面板的所有状态，而不是像现在一样保存整个面板。


## 一些需要注意的细节
- 1.场景的跳转，需要维护好旧界面的数据，注意**刷新**、**模型生成**等问题，避免新旧场景出现叠加模型，或者出现invalid model等trace。
- 2.通用面板的使用（如购买界面、兑换界面等），依赖了jump_to_recharge的回调，记得处理。

