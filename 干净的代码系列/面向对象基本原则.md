## 面向对象基本原则

**1. 单一职责原则（Single Responsibility Principle）**
- 每一个类应该专注于做一件事情。

**2. 里氏替换原则（Liskov Substitution Principle）**
- 超类存在的地方，子类是可以替换的。
- **接口级别的抽象（invalid s）**

**3. 依赖倒置原则（Dependence Inversion Principle）**
- 实现尽量依赖抽象，不依赖具体实现。
- 经典实现：使用接口，依赖于抽象。

**4. 接口隔离原则（Interface Segregation Principle）**
- 应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口。
- 评价：尽可能利用接口隔离依赖目标，完成该目标同时可实现DIP原则。

**5. 迪米特法则（Law Of Demeter）**
- 又叫最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用。
- 评：高内聚，低耦合。

**6. 开闭原则（Open Close Principle）**
- 面向扩展开放，面向修改关闭。
- 经典实现：子类化。

**7. 组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）**
- 尽量使用合成/聚合达到复用，尽量少用继承。原则： 一个类中有另一个类的对象。

## 面向对象的弊端是什么？
参考资料：invalid s知乎回答
1. 面向对象原本解决什么？封装、继承和多态。
   - 封装：封装的意义在于明确标识出允许外部使用的所有成员函数合数据项，或者叫接口。
     - 有了封装可以明确区分内外，类编写封装内的东西，不影响外部调用。
     - 提供良好的合作基础：只要**接口**这个基础约定不变，则代码改变不足为虑。
   - 继承+多态
     - 继承的两种含义
       - 继承基类方法，并做出自己的改变和扩展（号称解决代码重用问题）
   		> 评价：有害
       - 声明某个子类兼容于某基类（或者说，接口上完全兼容于基类），外部调用者无需关注其差别（内部机制会自动把请求派发dispatch到合适的逻辑）。
   		> **更重要的含义：接口继承**，“做出一个良好的抽象，这个抽象规定了一个兼容接口，使得外部调用者无需关心具体细节，可一视同仁的处理实现了特定接口的所有对象”——这在程序设计上，叫做归一化。
     - 多态：基于对象所属类的不同，外部对同一个方法的调用，执行的逻辑不同。
     - 多态依附于继承的两种含义，没有多态，继承的两种含义就不能实现。
   - 归一化
     - 使得高层的外部使用者可以不加区分的处理所有接口兼容的对象集合——类似于Linux的泛文件一样，所有东西当作文件处理，不必关心是内存、磁盘、网络还是屏幕（当然底层设计者可以区分出“字符设备”和“块设备”，做出针对设计，细致到什么程度，根据需求而定。
     - 实例
     	- a) 一切对象可以序列化/toString
   	- b) 一切UI对象都是个window，可以响应窗口事件。
   > 混淆概念辨析：一切（符合XX条件的）对象皆可以做什么，而不是“一切皆对象”。后者毫无意义，信息论角度，信息量为0）

2. **封装和归一化*才是战略层面问题*
   - 可以做到“一个师解决不了问题，再调两个师...”。软件设计内，叫做“通过合理模块化而灵活应对需求变更”。
   - 面向对象的好处就两点
     - 通过封装明确定义何谓接口、何谓接口的内部实现、何谓接口的外部调用者、使得大家各司其职，不得越界。
     - 通过继承+多态这种内置机制，在语言的层面支持归一化设计，使得内行可以从代码本身看到这个设计。（支持这种设计并不能让外行从这种设计中获得好处）
   - 不用面向对象语言、class也能做到归一化设计。

