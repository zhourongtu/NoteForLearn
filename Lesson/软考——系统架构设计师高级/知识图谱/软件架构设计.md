
- 软件架构的概念 ⭐⭐⭐
- 软件架构风格 ⭐⭐⭐⭐⭐
- 架构描述语言ADL ⭐⭐⭐
- 特定领域软件架构 ⭐⭐⭐
- 基于架构的软件开发 ⭐⭐⭐⭐
- 软件质量属性 ⭐⭐⭐⭐⭐
- 软件架构评估 ⭐⭐⭐⭐⭐
- 软件产品线 ⭐⭐⭐
- 构件与中间件技术 ⭐⭐⭐⭐
- Web架构设计 ⭐⭐⭐⭐⭐


- 概念、风格、设计、评估+Web应用技术维度


## 软件架构的概念
- 软件架构概念
  体系结构 = 架构
  架构设计就是需求分配，即将满足需求的职责分配到组件上
  - 需求分析（业务） | 架构 | 软件设计
  - 架构-->处于的阶段？
  - 架构设计
  - 软件架构是什么？有什么好处？
- 软件架构发展史

- 软件架构建模
  - `结构模型`：以架构的构件、连接件和其他概念来刻画结构
  - 框架模型
  - `动态模型`
  - 过程模型
  - 功能模型
- 4+1模型和UML的关系
  - 逻辑视图-->UML逻辑视图：系统功能
  - 开发视图-->UML实现视图：源代码
  - 进程视图-->UML进程视图：性能、可扩展性、吞吐量等（并发层次）
  - 物理视图-->UML部署视图：软件到硬件的映射关系
  - 场景-->UML用例视图

## 软件架构风格
> 论文：软件架构风格的应用？案例分析：系统中用到什么样的架构风格？特点、优势。选择判断...
**概览**
> 问题的通用解决方案
- 架构设计的核心问题：能否达到架构级的软件复用
- 架构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将各个构件有效地组织成一个完整的系统。
- 架构风格定义了用于描述系统的术语表和一组指导构建系统的规则。

**风格概览**
- 数据流风格：批处理序列，管道过滤器
  > 网络通信先包头分离，然后再报文解析，后续处理。  
  - 适合数据处理，一步一步得到结果
  - 例子：编译
- 调用/返回风格：主程序/子程序、面向对象、`层次结构`
- 独立构件风格：进程通信、事件驱动系统（隐式调用）
  > 断点，监视器做事情->隐式调用。
  > Windows图形方面 --> 事件驱动系统
- 虚拟机风格：解释器、基于规则的系统
  > Java、游戏开发自定义地图（解释器引擎支撑）
  - 工作流风格-->解释器
- 仓库风格：数据库系统、超文本系统、黑板系统
  > 集成编译环境，注意跟断点调试不一样。  
  > 语音识别（经典黑板）
- 其他风格：
  - 闭环控制
  - C2风格

> 机器人：过程调用（闭环控制）、解释器（自定义）、隐式调用？（选了这个，有瑕疵）  

### 具体风格介绍
- **数据流风格**
  - 批处理序列
    - 数据必须是完整的，以`整体`的方式传递
  - 管道过滤器
    - 过滤器：类似于函数、方法等
    - 管道：调用机制等（连接过滤器的方式）
      - 早期的编译器就采用这种架构。要一步一步处理的，均可考虑采用此架构风格。
      - 支持数据流的处理，连接件就是数据流传输的管道。
        - （视频）
- **调用/返回风格**
  - 应用最为广泛的架构风格
  - 分类
    - 主程序/子程序
      - 单线程控制，问题划分为若干个处理步骤，构件即为主程序和子程序，子程序通常可合成为模块。过程调用作为交互机制，即充当连接件的角色。
      - 调用关系具有层次性，语义逻辑表现为主程序的正确性取决于它调用的子程序的正确性。
    - 面向对象
      - 构件是对象，对象是抽象数据类型的实例
    - 层次结构
      - 构件组织成一个层级结构
  - 优缺点
    - 优点（解耦、等。。。）
      - 1.这种风格支持基于可增加抽象层的设计，允许将一个复杂问题分解成一个增量步骤序列的实现。**简化复杂问题**
      - 2.不同的层次处于不同的抽象级别
        - 底层：抽象级别越高
        - 顶层：抽象级别越低
      - 3.每一层最多影响两层。**利于复用**
    - 缺点
      - 1.很多系统不好分层（效率等）
      - 2.很难找到一个合适的、正确的抽象方法。
- **`独立` `构件`风格**
  > 不直接关联-->消息、事件
  - 进程通信
    - 消息传递的方式：点对点、同步或异步、远程过程（方法）调用。
  - 事件驱动系统（隐式调用）
    - 注册、分发。
- 虚拟机风格（层次比设计模式的解释器模式更高）
  - 解释器（更普遍）
    - 解释引擎（可以完整解释工作）、存储区（代码）、数据结构（工作状态）、数据结构（进度）
    - 虚拟机
  - 基于规则的系统（更高级
    - 解释引擎+知识层面的东西，`人工智能`、`辅助决策领域`
- **仓库风格（中心仓库+一堆处理部件）**
  - 数据库系统
  - 黑板系统
    - 黑板共享数据
    - 信号处理、问题规划和编译器优化等复杂问题-->使用黑板系统
  - 超文本系统（**归属于仓库风格**）
  - `现代集成编译环境采取仓库风格`
    - 语法树-编辑器、调试器、变量监控、断点（管控语法树）

**其他架构说明**
- 闭环控制架构（过程控制）
  - 反馈循环
  - 适合嵌入式系统，涉及连续的动作与状态
  - 基本结构
    - 给定值、比较器（反馈量与给定值）、控制器、执行器、被控对象
    - 反馈环节
- C2风格（分层机制）
  - 并行构件网络
  - 顶部和底部的连接

**用的比较多的架构风格细讲**
- 层次架构风格（调用/返回风格）
  - 两层C/S（移植维护复杂）、三层C/S（表示层、功能层、数据层）、三层B/S（小程序）（页面为单位，动态交互性不强，不安全）、混合架构（内、外使用B/S与C/S）
    - 三层B/S
      - 表示层：MVC、MVP、MVVM
      - 中间层
      - 数据访问层：ORM
      - 数据架构层
- MVC架构风格（有主动和被动）
  - J2EE体系结构
    - V：JSP
    - C：Servlet
    - M：Entity Bean、Session Bean
- MVP架构风格
  - 核心：解耦
  - V和M的解耦（分层）
- MV（VM）架构风格
  - VM做双向自动绑定
- 富互联网应用（RIA）
  - 结合C/S架构，B/S架构-->缓存
- **SOA**：基于服务的架构（跨平台、跨语言）
  - 标准化
  - 服务总线（ESB）--> 中介者的角色，信息路由。
  - 服务
    - 服务接口
  - 特点
    > 服务、构件、对象讨论特点。
    - 松散耦合
    - 粗粒度
    - 标准化接口
  - 实现：Web Service
    - 服务请求者、服务提供者、注册中心（WSDL协议？）
    - 底层传输层、服务通信协议层、服务描述层、服务层、业务流程层、服务注册层
    - 静态绑定（不需要注册中心）、动态绑定（通过注册中心来绑定）
  - 实现：ESB
    - 提供透明的消息路由和寻址服务（不需要管谁提供服务）
    - 注册和命名
    - 多种消息传递范型
    - 多种传输协议
    - 多种数据格式及互转
    - 提供日志和监控功能
  - 实现：服务注册表（差不多）
  > Web Service 和 ESB 的区别？可互补。
  - 关键技术
    - UDDI...
    - WSDL、XML Schema
    - XML（DOM、SAX）
    - SOAP:HTTP+XML
    - REST:抽象资源
      - **无状态**
- 微服务风格（面向服务架构的一种）
  - 特点
    - 小、专注于一件事
    - 轻量级的通信机制
    - 松散耦合、独立部署
    - 比喻：雕版印刷和活字印刷。
    > 容器技术发展
  - 优势
    - 技术异构性
    - 弹性
    - 扩展
    - 简化部署（自动化部署）
    - 与组织结构相匹配
    - 可组合性
    - 对可替代性的优化
  - 挑战
    - 分布式系统的复杂性
    - 运维成本
    - 部署自动化
    - DevOps与组织结构
    - 服务间依赖测试
    - 服务间依赖管理
  - **微服务和SOA的对比分析**
    - 微服务                      SOA
    - 能拆就拆                整体的，服务能在一起就在一起
    - 纵向业务划分            水平划分
    - 单一组织负责            按层级划分不同部门的组织负责
    - 细粒度                  粗粒度
    - 两句话可解释明白        几百字代表SOA的目录
    - 独立的子公司            类似大公司划分了业务单元（BU）
    - 组件小                  存在较复杂的组件
    - 业务逻辑存在于每个服务中    业务逻辑横跨多个业务领域
    - 使用轻量级通信方式，如HTTP  ESB充当服务通信的角色（企业服务产总线）
  - **微服务和SOA的对比分析（实现）**

- MDA（模型驱动架构）
  > 一部分应用可行。（业务逻辑绕不开的）
  - Model（客观事物的抽象表示）、Architecture（构成系统的部件、连接件+规约）
  - 目标：可移植性、互通信、可重用性
  - 使用模型完成软件的分析、设计、构建、部署、维护等
  - MDA起源于分离系统规约和平台实现的思想。
  - 三种模型
    - 平台独立模型（PIM）↓
    - 平台相关模型（PSM）↓
    - 代码（Code）

## 架构描述语言 ADL
- ADL由哪几部分构成
  - 构件：计算或存储的单元
  - 连接件：用于构件之间交互建模的`体系结构构造块`及其支配这些交互的规则；
  - 架构配置：描述体系结构的构件和连接件的连接图
- 主要的ADL
  - Aespo、MetaH、C2、Rapide、SADL、Unicon、Wright

## 特定领域软件架构（DSSA）
- 领域分析
- 领域设计
- 领域实现

- 垂直域
- 水平域

- 人：
  - 领域专家：理解为军师
    - 用户+专业工程师
  - 领域分析人员
  - 领域设计人员
  - 领域实现人员
- 三层次模型
  - 领域架构师——领域开发环境
    - 开发共性的东西
  - 应用工程师——领域特定的应用开发环境
    - 利用前者，结合用户需求
  - 操作员——应用执行环境

## 基于架构的软件开发方法（ABSD）Architecture、Base、Software、Design
- ABSD方法是`架构驱动`，即`强调由业务、质量和功能需求的组合驱动架构设计`
- 从总体功能架构明确，此时未完成需求获取与分析
- 三个基础
  - **功能分解**
  - **选择架构风格实现质量和业务需求**
  - **软件模板的使用**
- 过程递归
- 视角（看问题角度）与视图（视图）
- `用例用来捕获功能需求、特定场景用于捕获质量需求`
  - 质量需求：非功能需求

**开发过程**
> ABSD可以很好地支持软件重用
- 架构需求过程
  - 需求获取、`标识构件（生成类图、对类进行分组、把类打包成构件）`、需求评审
  - 注意：**标识构件这件事的发生在需求**。
- 架构设计
- 架构文档化——`架构规格说明书、测试架构需求的质量设计说明书`
  - 文档从使用者角度编写
  - 必须分发给所有系统相关人员
  - 且必须保证开发者手上的文档是最新的
- 架构复审
  - `标识潜在的风险`，及早`发现架构中的错误与缺陷`。
- 架构实现
  - 构件库：分析与设计、构件实现、构件组装、系统测试
- 架构演化

## 软件架构评估（架构复审的地方）
- 为什么要进行架构评估？
- 架构评估到底评估什么？
- 架构评估怎么评？

**质量属性**
- 性能
  - 系统的`响应能力`
  - 代表参数：响应时间、吞吐量
  - 设计策略：优先级队列、资源调度
- 可用性
  - 正常运行的时间比例
  - 代表参数：故障间隔时间
  - 设计策略：冗余、心跳线
- 安全性
  - 向合法用户提供服务的时间能够阻止`非授权`用户使用的企图或拒绝服务的能力
  - 设计策略：追踪审计
- 可修改性
  - 较高的性能价格比对系统进行变更的能力
  - 主要策略：信息隐藏
- 可靠性（可用性和可靠性是一致的）
  - 主要考虑两个方面：容错和健壮性
  > 除非特地强调健壮性
  - 代表参数：MTTF、MTBF
  - 设计策略：冗余、心跳线
- 功能性
- 可变性
- 互操作性

**必要概念**
- 风险点：系统架构设计过程中，架构设计中存在的隐患，潜在的问题。
- 非风险点：提出一个要求，某某要求是可以接受的。
- 敏感点：为了实现某种特定的质量属性，一个或多个构件所具有的特性。
- 权衡点（尽可能选权衡点）：是一个特殊的敏感点
  - `影响多个质量属性的特点`，是多个质量属性的敏感点
- 方法
  - 问卷调查
  - 基于度量的方式
  - **基于场景的方式**
    - 刺激系统得到响应
    - SAAM（软件架构分析法）
      > 识别非功能性需求
      - 最初：**可修改性**
      - 问题描述、需求说明、架构描述-->SAAM-->场景开发（架构描述）、单个场景评估、多场景评估、总体评估
    - ATAM（架构权衡分析法）
      - 在SAAM上发展来的
      - 性能、实用性（可用性）、安全性、可修改性
      - 强调：**多属性的折衷与平衡**。
      - 流程
        - 场景收集
        - 架构视图和场景实现
          - 描述架构视图
          - 实现场景
        - 属性模型构造和分析
          - 质量效用树
        - 折中
    - CBAM（成本效益分析法）


## 软件产品线
- 结合了：软件架构、领域工程、DSSA
- 双生命周期模型
  > 分析、设计、实现，一环扣一环
  - 领域工程（做共性）
  - 应用工程（做个性化）
- SEI模型
- 建立方式
  - 现有产品、全新
  - 演化式、革命式
  - 四种方法
  - 现有+演化 --> 稳
  - 全新+革命式 --> 高风险
- 组织结构
  - 设立独立核心资源组
  - 不设立
  - 动态的组织结构
- 因素
  - 经验、资源、好的产品线架构、好的管理支持


## 构件和中间件（是构件的一种）
**构件的定义**
- 1.软件构件式一种`组装单元`，它具有规范的接口规约和显式的语境依赖。软件构件可以独立地部署并由第三方任意的组装。
- 2.....
- 3...
- **构件特性**
  - 1.独立部署单元
  - 2.作为第三方组装。
  - 3.没有外部的可见状态。
- 对象特性
  - 1.一个单元的实例，具有唯一的标识。
  - 2.具有状态。
  - 3.封装了自己的状态和行为。
- 模块的特性
  - 结构化开发的产物

**构件系统架构特性**

**构件的复用**
- 检索和提取构件。-->理解与评价构件-->修改构件-->组装构件。


