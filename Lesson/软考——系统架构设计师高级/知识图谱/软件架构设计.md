
- 软件架构的概念 ⭐⭐⭐
- 软件架构风格 ⭐⭐⭐⭐⭐
- 架构描述语言ADL ⭐⭐⭐
- 特定领域软件架构 ⭐⭐⭐
- 基于架构的软件开发 ⭐⭐⭐⭐
- 软件质量属性 ⭐⭐⭐⭐⭐
- 软件架构评估 ⭐⭐⭐⭐⭐
- 软件产品线 ⭐⭐⭐
- 构件与中间件技术 ⭐⭐⭐⭐
- Web架构设计 ⭐⭐⭐⭐⭐


- 概念、风格、设计、评估+Web应用技术维度


## 软件架构的概念
- 软件架构概念
  体系结构 = 架构
  架构设计就是需求分配，即将满足需求的职责分配到组件上
  - 需求分析（业务） | 架构 | 软件设计
  - 架构-->处于的阶段？
  - 架构设计
  - 软件架构是什么？有什么好处？
- 软件架构发展史

- 软件架构建模
  - `结构模型`：以架构的构件、连接件和其他概念来刻画结构
  - 框架模型
  - `动态模型`
  - 过程模型
  - 功能模型
- 4+1模型和UML的关系
  - 逻辑视图-->UML逻辑视图：系统功能
  - 开发视图-->UML实现视图：源代码
  - 进程视图-->UML进程视图：性能、可扩展性、吞吐量等（并发层次）
  - 物理视图-->UML部署视图：软件到硬件的映射关系
  - 场景-->UML用例视图

## 软件架构风格
> 论文：软件架构风格的应用？案例分析：系统中用到什么样的架构风格？特点、优势。选择判断...
**概览**
> 问题的通用解决方案
- 架构设计的核心问题：能否达到架构级的软件复用
- 架构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将各个构件有效地组织成一个完整的系统。
- 架构风格定义了用于描述系统的术语表和一组指导构建系统的规则。

**风格概览**
- 数据流风格：批处理序列，管道过滤器
  > 网络通信先包头分离，然后再报文解析，后续处理。  
  - 适合数据处理，一步一步得到结果
  - 例子：编译
- 调用/返回风格：主程序/子程序、面向对象、`层次结构`
- 独立构件风格：进程通信、事件驱动系统（隐式调用）
  > 断点，监视器做事情->隐式调用。
  > Windows图形方面 --> 事件驱动系统
- 虚拟机风格：解释器、基于规则的系统
  > Java、游戏开发自定义地图（解释器引擎支撑）
  - 工作流风格-->解释器
- 仓库风格：数据库系统、超文本系统、黑板系统
  > 集成编译环境，注意跟断点调试不一样。  
  > 语音识别（经典黑板）
- 其他风格：
  - 闭环控制
  - C2风格

> 机器人：过程调用（闭环控制）、解释器（自定义）、隐式调用？（选了这个，有瑕疵）  

### 具体风格介绍
- **数据流风格**
  - 批处理序列
    - 数据必须是完整的，以`整体`的方式传递
  - 管道过滤器
    - 过滤器：类似于函数、方法等
    - 管道：调用机制等（连接过滤器的方式）
      - 早期的编译器就采用这种架构。要一步一步处理的，均可考虑采用此架构风格。
      - 支持数据流的处理，连接件就是数据流传输的管道。
        - （视频）
- **调用/返回风格**
  - 应用最为广泛的架构风格
  - 分类
    - 主程序/子程序
      - 单线程控制，问题划分为若干个处理步骤，构件即为主程序和子程序，子程序通常可合成为模块。过程调用作为交互机制，即充当连接件的角色。
      - 调用关系具有层次性，语义逻辑表现为主程序的正确性取决于它调用的子程序的正确性。
    - 面向对象
      - 构件是对象，对象是抽象数据类型的实例
    - 层次结构
      - 构件组织成一个层级结构
  - 优缺点
    - 优点（解耦、等。。。）
      - 1.这种风格支持基于可增加抽象层的设计，允许将一个复杂问题分解成一个增量步骤序列的实现。**简化复杂问题**
      - 2.不同的层次处于不同的抽象级别
        - 底层：抽象级别越高
        - 顶层：抽象级别越低
      - 3.每一层最多影响两层。**利于复用**
    - 缺点
      - 1.很多系统不好分层（效率等）
      - 2.很难找到一个合适的、正确的抽象方法。
- **`独立` `构件`风格**
  > 不直接关联-->消息、事件
  - 进程通信
    - 消息传递的方式：点对点、同步或异步、远程过程（方法）调用。
  - 事件驱动系统（隐式调用）
    - 注册、分发。
- 虚拟机风格（层次比设计模式的解释器模式更高）
  - 解释器（更普遍）
    - 解释引擎（可以完整解释工作）、存储区（代码）、数据结构（工作状态）、数据结构（进度）
    - 虚拟机
  - 基于规则的系统（更高级
    - 解释引擎+知识层面的东西，`人工智能`、`辅助决策领域`
- **仓库风格（中心仓库+一堆处理部件）**
  - 数据库系统
  - 黑板系统
    - 黑板共享数据
    - 信号处理、问题规划和编译器优化等复杂问题-->使用黑板系统
  - 超文本系统（**归属于仓库风格**）
  - `现代集成编译环境采取仓库风格`
    - 语法树-编辑器、调试器、变量监控、断点（管控语法树）

**其他架构说明**
- 闭环控制架构（过程控制）
  - 反馈循环
  - 适合嵌入式系统，涉及连续的动作与状态
  - 基本结构
    - 给定值、比较器（反馈量与给定值）、控制器、执行器、被控对象
    - 反馈环节
- C2风格（分层机制）
  - 并行构件网络
  - 顶部和底部的连接

**用的比较多的架构风格细讲**
- 层次架构风格（调用/返回风格）
  - 两层C/S（移植维护复杂）、三层C/S（表示层、功能层、数据层）、三层B/S（小程序）（页面为单位，动态交互性不强，不安全）、混合架构（内、外使用B/S与C/S）
    - 三层B/S
      - 表示层：MVC、MVP、MVVM
      - 中间层
      - 数据访问层：ORM
      - 数据架构层
- MVC架构风格（有主动和被动）
  - J2EE体系结构
    - V：JSP
    - C：Servlet
    - M：Entity Bean、Session Bean
- MVP架构风格
  - 核心：解耦
  - V和M的解耦（分层）
- MV（VM）架构风格
  - VM做双向自动绑定
- 富互联网应用（RIA）
  - 结合C/S架构，B/S架构-->缓存
- **SOA**：基于服务的架构（跨平台、跨语言）
  - 标准化
  - 服务总线（ESB）--> 中介者的角色，信息路由。
  - 服务
    - 服务接口
  - 特点
    > 服务、构件、对象讨论特点。
    - 松散耦合
    - 粗粒度
    - 标准化接口
  - 实现：Web Service
    - 服务请求者、服务提供者、注册中心（WSDL协议？）
    - 底层传输层、服务通信协议层、服务描述层、服务层、业务流程层、服务注册层
    - 静态绑定（不需要注册中心）、动态绑定（通过注册中心来绑定）
  - 实现：ESB
    - 提供透明的消息路由和寻址服务（不需要管谁提供服务）
    - 注册和命名
    - 多种消息传递范型
    - 多种传输协议
    - 多种数据格式及互转
    - 提供日志和监控功能
  - 实现：服务注册表（差不多）
  > Web Service 和 ESB 的区别？可互补。
  - 关键技术
    - UDDI...
    - WSDL、XML Schema
    - XML（DOM、SAX）
    - SOAP:HTTP+XML
    - REST:抽象资源
      - **无状态**
- 微服务风格（面向服务架构的一种）
  - 特点
    - 小、专注于一件事
    - 轻量级的通信机制
    - 松散耦合、独立部署
    - 比喻：雕版印刷和活字印刷。
    > 容器技术发展
  - 优势
    - 技术异构性
    - 弹性
    - 扩展
    - 简化部署（自动化部署）
    - 与组织结构相匹配
    - 可组合性
    - 对可替代性的优化
  - 挑战
    - 分布式系统的复杂性
    - 运维成本
    - 部署自动化
    - DevOps与组织结构
    - 服务间依赖测试
    - 服务间依赖管理
  - **微服务和SOA的对比分析**
    - 微服务                      SOA
    - 能拆就拆                整体的，服务能在一起就在一起
    - 纵向业务划分            水平划分
    - 单一组织负责            按层级划分不同部门的组织负责
    - 细粒度                  粗粒度
    - 两句话可解释明白        几百字代表SOA的目录
    - 独立的子公司            类似大公司划分了业务单元（BU）
    - 组件小                  存在较复杂的组件
    - 业务逻辑存在于每个服务中    业务逻辑横跨多个业务领域
    - 使用轻量级通信方式，如HTTP  ESB充当服务通信的角色（企业服务产总线）
  - **微服务和SOA的对比分析（实现）**

- MDA（模型驱动架构）
  > 一部分应用可行。（业务逻辑绕不开的）
  - Model（客观事物的抽象表示）、Architecture（构成系统的部件、连接件+规约）
  - 目标：可移植性、互通信、可重用性
  - 使用模型完成软件的分析、设计、构建、部署、维护等
  - MDA起源于分离系统规约和平台实现的思想。



